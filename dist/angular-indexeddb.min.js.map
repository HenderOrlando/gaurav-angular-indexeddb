{"version":3,"sources":["angular-indexeddb.min.js","angular-indexeddb.js"],"names":["indexeddbProvider","$windowProvider","initialize","$q","CreateDB","name","version","_check","self","indexdb","$window","indexedDB","mozIndexedDB","webkitIndexedDB","msIndexedDB","keyRange","IDBKeyRange","mozIDBKeyRange","webkitIDBKeyRange","msIDBKeyRange","this","open","Promise","resolve","reject","connection","onupgradeneeded","event","onerror","onsuccess","openConnection","DBHelper","helper","helperObject","isDesc","changeCase","value","toUpper","caseInsensitive","undefined","toUpperCase","toLowerCase","checkLikeString","recordKey","likeString","key","angular","copy","toString","match","whereIn","result","whereInValues","resultKey","isInValue","forEach","lowerValue","indexOf","setOrderSettings","inValues","isNumber","sort","_sortAsNumbers","reverse","sortAsNumbers","a","b","whereNotIn","exists","getPropertyValue","property","i","properties","propertyValue","split","length","maxValue","value1","value2","minValue","CreateTables","tables","qRes","qRej","CreateModelBuilder","table","_defaultModelSettings","model","bound","index","hasFilter","filterFunction","whereNotInValues","withTables","hasWith","traverse","isWhereNumber","originalWithRelation","andObject","orObject","inObject","notInObject","_setWithRelation","relations","Object","keys","tableName","withTable","filter","exisitingTable","gt","lower","lowerBound","gte","lte","upper","upperBound","lt","orderDesc","select","fields","keyPathField","equal","where","only","setCaseInsensitive","incUpper","incLower","lowerOpen","upperOpen","between","notInValues","like","withRelations","withRelation","whereOther","whereOtherAnd","propertyName","push","whereOtherOr","whereOtherIn","constructor","Array","whereOtherNotIn","CreateAggregateBuilder","aggregate","sums","mins","maxs","averages","customs","call","sum","min","max","average","custom","callback","endCallback","customObject","testDuplicate","CreateModel","_checkResult","andStatus","orStatus","hasAnd","_getTransactionTables","transactionTables","_get","readwrite","write","then","db","target","transaction","splice","objectStore","openCursor","exception","abort","error","_updateValue","data","hasTimeStamp","newValue","updatedAt","Date","parse","CreateAggregate","count","c","m","outcome","cust","apply","withRelationObject","aggregateObject","getRelationData","isFind","_id","setOutcome","withTableName","relationsData","tableSchema","tableObject","Relations","relationData","outcomeData","getWithAllData","objectStoreTables","withTablesCount","relationNames","currentCount","field","currentOutcome","cursor","e","getSums","getMins","getMaxs","getAverages","resultOrCount","finalCalculation","getCustoms","update","record","relation","add","manyOutcome","isMany","many","newObjectStore","put","destroy","isDestroy","find","getId","get","createdAt","srcElement","addMultiple","inserted","toAddData","getAll","Error","objectStoreDelete","deleteId","deletedIds","del","getAggregate","ag","_getFieldConfig","config","hasOwnProperty","unique","multiEntry","_getIndexValue","keyPathValue","_createModelInstance","objectStoreNames","contains","keyPath","models","defineProperty","_createTables","other","indexValue","indexNames","createIndex","createObjectStore","autoIncrement","_setFields","j","newFields","fieldNames","_setTables","tableNames","timeStamps","indexOnTimeStamps","l","type","res","rej","dbName","dbVersion","dbTables","setDbName","setDbTables","setDbVersion","$get","$inject","module","provider"],"mappings":"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","file":"angular-indexeddb.min.js","sourcesContent":[null,"/*jslint browser: true*/\n/*global $q */\nfunction indexeddbProvider($windowProvider) {\n    'use strict';\n    var $window = $windowProvider.$get();\n\n    var dbName, dbVersion, dbTables;\n    dbName = 'test';\n    dbVersion = 1;\n    dbTables = [];\n\n\n    function initialize($q) {\n        /**\n         * Class : Function creates database and provides $q when database connection is resolved\n         * @param {string} name    [name of database]\n         * @param {integer} version [contains version number]\n         */\n        function CreateDB(name, version) {\n            var self = this;\n            self.name = name;\n            self.version = version;\n            self.indexdb = \"\";\n\n            /**\n             * Private : checks whether indexdb is supported by browser or not\n             */\n            function _check() {\n                self.indexdb = $window.indexedDB || $window.mozIndexedDB || $window.webkitIndexedDB || $window.msIndexedDB;\n                if (typeof self.indexdb !== \"object\") {\n                    throw \"IndexedDB not supported\";\n                }\n                self.keyRange = $window.IDBKeyRange || $window.mozIDBKeyRange || $window.webkitIDBKeyRange || $window.msIDBKeyRange;\n            }\n\n            _check();\n\n            //connection opening for updating database\n            self.open = new $window.Promise(function (resolve, reject) {\n\n                var connection = self.indexdb.open(self.name, self.version);\n                connection.onupgradeneeded = function (event) {\n                    resolve(event);\n                };\n                connection.onerror = function (event) {\n                    reject(event);\n                };\n\n                connection.onsuccess = function (event) {\n                    resolve(event);\n                };\n            });\n\n            //open database in default version\n            self.openConnection = new $window.Promise(function (resolve, reject) {\n\n                var connection = self.indexdb.open(self.name);\n                connection.onerror = function (event) {\n                    reject(event);\n                };\n\n                connection.onsuccess = function (event) {\n                    resolve(event);\n                };\n            });\n        }\n\n        /**\n         * Class : Helper class with various helper functions\n         */\n        function DBHelper() {\n            var helper = this;\n            var helperObject = {};\n            helperObject.isDesc = false;\n\n            //function changes case of value if string type to lower or upper\n            helper.changeCase = function (value, toUpper, caseInsensitive) {\n                toUpper = (toUpper === undefined) ? false : toUpper;\n                if (caseInsensitive) {\n                    if (typeof value === 'string') {\n                        value = (toUpper === true) ? value.toUpperCase() : value.toLowerCase();\n                    }\n                }\n\n                return value;\n            };\n\n            //function checks for like functionality in record key value\n            helper.checkLikeString = function (recordKey, likeString, caseInsensitive) {\n                var key = angular.copy(recordKey);\n                key = key.toString();\n\n                //if case insensitive\n                if (caseInsensitive) {\n                    key = key.toLowerCase();\n                    return (key.match(likeString.toLowerCase()) !== null);\n                }\n\n                return (key.match(likeString) !== null);\n            };\n\n            /**\n             * The where in logic for the object store\n             * @param  {integer/string} result             [contains value to be checked against]\n             * @param  {array} whereInValues      [whereIn values to search for]\n             * @param  {boolean} useCaseInsensitive [override case sensitive search]\n             * @return {boolean}                    [true if exists in list]\n             */\n            helper.whereIn = function (result, whereInValues, caseInsensitive) {\n\n                caseInsensitive = (caseInsensitive === undefined) ? false : caseInsensitive;\n\n                //if case sensitive then checking throughout th database\n                if (caseInsensitive) {\n                    var resultKey, isInValue;\n                    isInValue = false;\n\n                    resultKey = helper.changeCase(result, false, true);\n\n                    //checking each where in value against the main result value both in lower case\n                    whereInValues.forEach(function (value) {\n                        var lowerValue = helper.changeCase(angular.copy(value), false, true);\n                        if (lowerValue === resultKey) {\n                            isInValue = true;\n                        }\n                    });\n\n                    return isInValue;\n                }\n\n                return (whereInValues.indexOf(result) !== -1);\n            };\n\n            helper.setOrderSettings = function (inValues, isNumber, isDesc) {\n                //setting wherein, where not in as values of is desc for sorting\n                if (isDesc) {\n                    helperObject.isDesc = true;\n                }\n\n                if (isNumber) {\n                    inValues = inValues.sort(helperObject._sortAsNumbers);\n\n                } else {\n                    inValues = (helperObject.isDesc) ? inValues.reverse() : inValues.sort();\n                }\n\n                helperObject.isDesc = false;\n                return inValues;\n            };\n\n            //sorting where in/ where not in as number\n            helper.sortAsNumbers = function (a, b) {\n\n                //if desc then returning b-a for descending values\n                if (helperObject.isDesc) {\n                    return (b - a);\n                }\n\n                //returning ascending values\n                return (a - b);\n            };\n\n            //function for where not in logic \n            helper.whereNotIn = function (result, inValues, caseInsensitive) {\n                //case sensitive\n                if (caseInsensitive) {\n                    var resultKey = helper.changeCase(result, false, true);\n                    var exists = false;\n\n                    inValues.forEach(function (value) {\n                        var lowerValue = helper.changeCase(angular.copy(value), false, true);\n\n                        //checking if current value doesn't exist in inValues while caseInsensitive\n                        if (lowerValue === resultKey) {\n                            exists = true;\n                        }\n                    });\n\n                    if (!exists) {\n                        return true;\n                    }\n\n                } else {\n                    if (inValues.indexOf(result) === -1) {\n                        return true;\n                    }\n                }\n\n                return false;\n            };\n\n            //function takes in string values in dotted format and returns the value at the result param\n            helper.getPropertyValue = function (property, result) {\n                var propertyValue = angular.copy(result);\n                var i, properties;\n                properties = property.split('.');\n\n                if (properties.length > 1) {\n                    for (i = 0; i <= properties.length - 1; i++) {\n                        //if any of the property value is undefined then returning\n                        if (propertyValue[properties[i]] === undefined) {\n                            return undefined;\n                        }\n                        propertyValue = propertyValue[properties[i]];\n                    }\n\n                } else {\n                    propertyValue = propertyValue[properties[0]];\n                }\n\n                return propertyValue;\n            };\n\n\n            //compares two values and returns the larger one\n            helper.maxValue = function (value1, value2) {\n                if (value1 >= value2) {\n                    return value1;\n                }\n\n                return value2;\n            };\n\n            //compares two values and returns the smaller one\n            helper.minValue = function (value1, value2) {\n                if (value1 <= value2) {\n                    return value1;\n                }\n\n                return value2;\n            };\n        }\n\n        /**\n         * Class : class for maintaining and creating tables\n         * @param {string} name    [database name]\n         * @param {integer} version [version of database]\n         * @param {array} tables  [contains tables to be created]\n         */\n        function CreateTables(name, version, tables, qRes, qRej) {\n            CreateDB.apply(this, [name, version]);\n            this.helper = {};\n            DBHelper.apply(this.helper, []);\n\n            var self = this;\n            self.tables = tables || [];\n            self.models = {};\n\n            /**\n             * Class : class for maintaining builder functions of model\n             * @param {array} table [table to act against] aggregate\n             */\n            function CreateModelBuilder(table) {\n                var model = this;\n\n                //private : function sets the model default settings\n                function _defaultModelSettings() {\n                    model.bound = null; //default bound value\n                    model.index = null; //default index value\n                    model.caseInsensitive = false; //default caseInsensitive value\n                    model.hasFilter = false; //default if model has filter\n                    model.filterFunction = null; //default filter function\n                    model.whereInValues = null; //default whereInValues for whereIn\n                    model.whereNotInValues = null; //default whereNotInValues for whereNotIn\n                    model.withTables = {}; //with tables structure\n                    model.hasWith = false; //default has with relation status\n                    model.isDesc = false; //default descending traverse set to false\n                    model.traverse = 'next'; //default traversing set to ascending\n                    model.isWhereNumber = false; //default where clause not containing number\n                    model.originalWithRelation = null; //default original with relation data\n                    model.likeString = null; //default likeString data\n                    model.andObject = null; //default andObject data\n                    model.orObject = null; //default orObject data\n                    model.inObject = null; //default inObject data\n                    model.notInObject = null; //default notInObject data\n                }\n\n                function _setWithRelation(relations) {\n                    var withTables = Object.keys(relations);\n\n                    withTables.forEach(function (tableName) {\n                        //creating model for each instance\n                        var withTable = self.tables.filter(function (exisitingTable) {\n                            return (exisitingTable.name === tableName);\n                        })[0];\n\n                        model.withTables[tableName] = new CreateModelBuilder(withTable);\n                    });\n                }\n\n                _defaultModelSettings();\n\n                //function sets greater than value for index\n                model.gt = function (lower) {\n                    lower = self.helper.changeCase(lower, true, model.caseInsensitive);\n                    model.bound = self.keyRange.lowerBound(lower, true);\n                    return model;\n                };\n\n                //function sets greater than value for index including the value\n                model.gte = function (lower) {\n                    lower = self.helper.changeCase(lower, true, model.caseInsensitive);\n                    model.bound = self.keyRange.lowerBound(lower);\n                    return model;\n                };\n\n                //function sets less than value for index including the value\n                model.lte = function (upper) {\n                    upper = self.helper.changeCase(upper, false, model.caseInsensitive);\n                    model.bound = self.keyRange.upperBound(upper);\n                    return model;\n                };\n\n                //function sets less than value for index\n                model.lt = function (upper) {\n                    upper = self.helper.changeCase(upper, false, model.caseInsensitive);\n                    model.bound = self.keyRange.upperBound(upper, true);\n                    return model;\n                };\n\n                //function traverse through reverse order i.e descending\n                model.orderDesc = function (isDesc) {\n                    model.isDesc = false;\n                    model.traverse = 'next';\n\n                    if (isDesc === true) {\n                        model.isDesc = true;\n                        model.traverse = 'prev';\n                    }\n\n                    if (model.whereInValues !== null) {\n                        model.whereInValues = self.helper.setOrderSettings(model.whereInValues, model.isWhereNumber, model.isDesc);\n                    }\n\n                    if (model.whereNotInValues !== null) {\n                        model.whereNotInValues = self.helper.setOrderSettings(model.whereNotInValues, model.isWhereNumber, model.isDesc);\n                    }\n\n                    return model;\n                };\n\n                //selecting index to make searches upon\n                model.select = function (index) {\n                    if (index === table.fields.keyPathField) {\n                        return model;\n                    }\n                    model.index = index;\n                    return model;\n                };\n\n                //function sets equal value for index searching (not case sensitive)\n                model.equal = function (where) {\n                    model.bound = self.keyRange.only(where);\n                    return model;\n                };\n\n                //sets searches to case sensitive\n                model.setCaseInsensitive = function (value) {\n                    var lower, upper, incUpper, incLower;\n\n                    value = (value === undefined || value === true) ? true : false;\n                    model.caseInsensitive = value;\n\n                    //if model has been set to case insensitive and bound values are defined then\n                    if (model.caseInsensitive && model.bound !== null) {\n\n                        //case not of equal\n                        if (model.bound.lower !== model.bound.upper) {\n\n                            //setting bound values against case insensitive\n                            lower = self.helper.changeCase(angular.copy(model.bound.lower), true, true);\n                            incLower = (model.bound.lowerOpen === undefined) ? false : angular.copy(model.bound.lowerOpen);\n                            upper = self.helper.changeCase(angular.copy(model.bound.upper), false, true);\n                            incUpper = (model.bound.upperOpen === undefined) ? false : angular.copy(model.bound.upperOpen);\n\n                            //if lower bound is undefined then setting only upper bound\n                            if (model.bound.lower === undefined) {\n                                model.bound = self.keyRange.upperBound(upper, incUpper);\n\n                            } else if (model.bound.upper === undefined) {\n                                //if upper bound is undefined then setting only upper bound\n                                model.bound = self.keyRange.lowerBound(lower, incLower);\n\n                            } else {\n                                //else setting both bound values\n                                model.bound = self.keyRange.bound(lower, upper, incLower, incUpper);\n                            }\n\n                        }\n                    }\n\n                    return model;\n                };\n\n                //between function(not case sensitive)\n                model.between = function (lower, upper, incLower, incUpper) {\n                    incLower = (incLower !== undefined) ? false : incLower;\n                    incUpper = (incUpper !== undefined) ? false : incUpper;\n\n                    //checking if work to do is caseInsensitive\n                    if (model.caseInsensitive) {\n                        lower = self.helper.changeCase(lower, true, true);\n                        upper = self.helper.changeCase(upper, false, true);\n                    }\n\n                    model.bound = self.keyRange.bound(lower, upper, incLower, incUpper);\n                    return model;\n                };\n\n                //where in model function for setting whereInValues\n                model.whereIn = function (inValues, sortAsNumbers) {\n\n                    sortAsNumbers = (sortAsNumbers === true) ? true : false;\n                    model.whereInValues = inValues;\n\n                    model.isWhereNumber = sortAsNumbers; //setting whereIn as number type\n\n                    if (model.caseInsensitive) {\n                        model.whereInValues = self.helper.setOrderSettings(model.whereInValues, sortAsNumbers, model.isDesc);\n                    }\n\n                    return model;\n                };\n\n                //function sets where not in values for model\n                model.whereNotIn = function (notInValues, sortAsNumbers) {\n\n                    sortAsNumbers = (sortAsNumbers === true) ? true : false;\n                    model.whereNotInValues = notInValues;\n\n                    model.isWhereNumber = sortAsNumbers; //setting whereNotInValues as number type\n\n                    if (model.caseInsensitive) {\n                        model.whereNotInValues = self.helper.setOrderSettings(model.whereNotInValues, sortAsNumbers, model.isDesc);\n                    }\n\n                    return model;\n                };\n\n                //functions sets the filter for traversing\n                model.filter = function (filterFunction) {\n                    model.hasFilter = true;\n                    if (typeof filterFunction !== 'function') {\n                        throw \"A function must be given as parameter for filter\";\n                    }\n                    model.filterFunction = filterFunction;\n                    return model;\n                };\n\n                //function sets the like string search setting\n                model.like = function (likeString) {\n                    if (likeString === undefined) {\n                        throw \"Invalid input given to like\";\n                    }\n\n                    model.likeString = likeString.toString();\n                    return model;\n                };\n\n                //query builder for with relations\n                model.withRelations = function (relations) {\n                    if (typeof relations !== 'object') {\n                        throw \"WithRelation must be at type of object\";\n                    }\n\n                    model.hasWith = true;\n                    model.originalWithRelation = relations; //keeping a record of original relation data\n                    model.withRelation = _setWithRelation(relations); //setting objects for using with relations\n\n                    return model;\n                };\n\n                //query builder for \n                model.whereOther = function (andObject, orObject, inObject, notInObject) {\n                    andObject = andObject || {};\n                    orObject = orObject || {};\n                    inObject = inObject || {};\n                    notInObject = notInObject || {};\n\n                    if (typeof andObject !== 'object') {\n                        throw \"Invalid argument provided. Argument must be of object type\";\n                    }\n\n                    if (typeof orObject !== 'object') {\n                        throw \"Invalid argument provided. Argument must be of object type\";\n                    }\n\n                    model.andObject = andObject;\n                    model.orObject = orObject;\n                    model.inObject = inObject;\n                    model.notInObject = notInObject;\n\n                    return model;\n                };\n\n                model.whereOtherAnd = function (propertyName, propertyValue) {\n                    var andObject = {};\n                    if (typeof propertyName !== \"string\") {\n                        throw \"Invalid first argument. Property name must be a string\";\n                    }\n\n                    if (model.andObject === null) {\n                        model.andObject = [];\n                    }\n\n                    andObject.propertyName = propertyName;\n                    andObject.propertyValue = propertyValue;\n\n                    model.andObject.push(andObject);\n\n                    return model;\n                };\n\n                model.whereOtherOr = function (propertyName, propertyValue) {\n                    var orObject = {};\n                    if (typeof propertyName !== \"string\") {\n                        throw \"Invalid first argument. Property name must be a string\";\n                    }\n\n                    if (model.orObject === null) {\n                        model.orObject = [];\n                    }\n\n                    orObject.propertyName = propertyName;\n                    orObject.propertyValue = propertyValue;\n\n                    model.orObject.push(orObject);\n\n                    return model;\n                };\n\n                model.whereOtherIn = function (propertyName, propertyValue) {\n                    var inObject = {};\n                    if (typeof propertyName !== \"string\") {\n                        throw \"Invalid first argument. Property name must be a string\";\n                    }\n\n                    if (propertyValue.constructor !== Array) {\n                        throw \"Invalid second argument. Property value must be an array\";\n                    }\n\n                    if (model.inObject === null) {\n                        model.inObject = [];\n                    }\n\n                    inObject.propertyName = propertyName;\n                    inObject.propertyValue = propertyValue;\n\n                    model.inObject.push(inObject);\n\n                    return model;\n                };\n\n                model.whereOtherNotIn = function (propertyName, propertyValue) {\n                    var notInObject = {};\n                    if (typeof propertyName !== \"string\") {\n                        throw \"Invalid first argument. Property name must be a string\";\n                    }\n\n                    if (propertyValue.constructor !== Array) {\n                        throw \"Invalid second argument. Property value must be an array\";\n                    }\n\n                    if (model.notInObject === null) {\n                        model.notInObject = [];\n                    }\n\n                    notInObject.propertyName = propertyName;\n                    notInObject.propertyValue = propertyValue;\n\n                    model.notInObject.push(notInObject);\n\n                    return model;\n                };\n\n            }\n\n            /**\n             * Class : Definition for aggregation builder\n             * @param {object} table [table/Object store of model]\n             */\n            function CreateAggregateBuilder(table) {\n                CreateModelBuilder.call(this, table);\n                var aggregate = this;\n\n                //function sets the default state of aggregate builder\n                function _defaultModelSettings() {\n                    aggregate.sums = [];\n                    aggregate.mins = [];\n                    aggregate.maxs = [];\n                    aggregate.averages = [];\n                    aggregate.customs = [];\n                }\n\n                _defaultModelSettings();\n\n                //function registers a sum aggregate against the property\n                aggregate.sum = function (property) {\n\n                    if (property === undefined) {\n                        property = (aggregate.index === null) ? table.fields.keyPathField : aggregate.index;\n                    }\n\n                    if (aggregate.sums.indexOf(property) === -1) {\n                        aggregate.sums.push(property);\n                    }\n\n                    return aggregate;\n                };\n\n                //function registers a min aggregate against the property\n                aggregate.min = function (property) {\n\n                    if (property === undefined) {\n                        property = (aggregate.index === null) ? table.fields.keyPathField : aggregate.index;\n                    }\n\n                    if (aggregate.mins.indexOf(property) === -1) {\n                        aggregate.mins.push(property);\n                    }\n\n\n                    return aggregate;\n                };\n\n                //function registers a max aggregate against the property\n                aggregate.max = function (property) {\n\n                    if (property === undefined) {\n                        property = (aggregate.index === null) ? table.fields.keyPathField : aggregate.index;\n                    }\n\n                    if (aggregate.maxs.indexOf(property) === -1) {\n                        aggregate.maxs.push(property);\n                    }\n\n                    return aggregate;\n                };\n\n                //function registers a average aggregate against the property\n                aggregate.average = function (property) {\n\n                    if (property === undefined) {\n                        property = (aggregate.index === null) ? table.fields.keyPathField : aggregate.index;\n                    }\n\n                    if (aggregate.averages.indexOf(property) === -1) {\n                        aggregate.averages.push(property);\n                    }\n\n                    return aggregate;\n                };\n\n                //function registers a custom aggregate against the property\n                aggregate.custom = function (name, callback, endCallback) {\n\n                    //checking various parameters before continuing\n                    if (typeof name !== 'string') {\n                        throw \"Custom aggregate first parameter must be a string\";\n                    }\n\n                    if (typeof callback !== 'function') {\n                        throw \"Custom aggregate second parameter must be a function\";\n                    }\n\n                    if (endCallback !== undefined) {\n                        if (typeof endCallback !== 'function') {\n                            throw \"Custom aggregate third parameter must be a function\";\n                        }\n                    }\n\n                    var customObject = {};\n                    customObject.callback = callback;\n                    customObject.endCallback = endCallback;\n                    customObject.name = name;\n\n                    var testDuplicate = aggregate.customs.filter(function (custom) {\n                        return (custom.name === name);\n                    });\n\n                    if (testDuplicate.length !== 0) {\n                        throw \"Repeated Custom aggregate name given : \" + name;\n                    }\n\n                    aggregate.customs.push(customObject);\n\n                    return aggregate;\n                };\n\n\n            }\n\n            /**\n             * Class : Final builder class that fires various action in promises\n             * @param {object} table [table/object store of model]\n             */\n            function CreateModel(table) {\n                CreateAggregateBuilder.apply(this, [table]);\n\n                var model = this;\n                var transaction;\n                var objectStore;\n                var withRelationObject = {};\n                var aggregateObject = {};\n\n                /**\n                 * Function checks result against various model filters\n                 * @param  {IDBCursor} result [contains the IDBCursor value against the current record]\n                 * @return {boolean}        [true if passes all]\n                 */\n                function _checkResult(result) {\n                    var i, propertyValue, andStatus, orStatus, hasAnd, property;\n                    andStatus = true;\n                    orStatus = false;\n                    hasAnd = false;\n\n                    //if model has filter\n                    if (model.hasFilter) {\n                        if (model.filterFunction(result.value) !== true) {\n                            return false;\n                        }\n                    }\n\n                    //checking for likeness in data\n                    if (model.likeString !== null) {\n                        if (self.helper.checkLikeString(result.key, model.likeString, model.caseInsensitive) === false) {\n                            return false;\n                        }\n                    }\n\n                    //first for whereIn model values then whereNotIn else default\n                    if (model.whereInValues !== null) {\n                        if (!self.helper.whereIn(result.key, model.whereInValues, model.caseInsensitive)) {\n                            return false;\n                        }\n\n                    }\n\n                    if (model.whereNotInValues !== null) {\n                        if (!self.helper.whereNotIn(result.key, model.whereNotInValues, model.caseInsensitive)) {\n                            return false;\n                        }\n\n                    }\n\n                    //checking other values as where not in conditions\n                    if (model.inObject !== null) {\n\n                        //for each condition set against the value\n                        for (i = model.inObject.length - 1; i >= 0; i--) {\n                            property = model.inObject[i];\n\n                            //fetching value at that propery in main result\n                            propertyValue = self.helper.getPropertyValue(property.propertyName, result.value);\n\n                            //if property value is undefined then returning false\n                            if (propertyValue === undefined) {\n                                return false;\n                            }\n\n                            if (!self.helper.whereIn(propertyValue, property.propertyValue, model.caseInsensitive)) {\n                                return false;\n                            }\n\n                        }\n                    }\n\n                    //checking other values as where in conditions\n                    if (model.notInObject !== null) {\n\n                        //for each condition set against the value\n                        for (i = model.notInObject.length - 1; i >= 0; i--) {\n                            property = model.notInObject[i];\n\n                            //fetching value at that propery in main result\n                            propertyValue = self.helper.getPropertyValue(property.propertyName, result.value);\n\n                            //if property value is undefined then returning false\n                            if (propertyValue === undefined) {\n                                continue;\n                            }\n\n                            if (!self.helper.whereNotIn(propertyValue, property.propertyValue, model.caseInsensitive)) {\n                                return false;\n                            }\n\n                        }\n                    }\n\n                    //checking other values as and conditions\n                    if (model.andObject !== null) {\n\n                        hasAnd = true;\n\n                        for (i = model.andObject.length - 1; i >= 0; i--) {\n                            property = model.andObject[i];\n\n                            propertyValue = self.helper.getPropertyValue(property.propertyName, result.value);\n\n                            if (propertyValue === undefined || propertyValue !== property.propertyValue) {\n                                andStatus = false;\n                                break;\n                            }\n                        }\n                    }\n\n                    if (model.orObject !== null) {\n                        orStatus = false;\n\n                        if (!hasAnd) {\n                            andStatus = false;\n                            if (model.orObject.length === 0) {\n                                return true;\n                            }\n                        }\n\n\n                        for (i = model.orObject.length - 1; i >= 0; i--) {\n                            property = model.orObject[i];\n\n                            propertyValue = self.helper.getPropertyValue(property.propertyName, result.value);\n\n                            if (propertyValue !== undefined && propertyValue === property.propertyValue) {\n                                orStatus = true;\n                                break;\n                            }\n                        }\n                    }\n\n                    if (!(andStatus || orStatus)) {\n                        return false;\n                    }\n\n                    return true;\n                }\n\n                //function : withRelation action to retrieve all relational data in main outcome \n                withRelationObject.getRelationData = function (outcome, isFind, propertyName) {\n                    var _id;\n                    if (isFind) {\n                        _id = angular.copy(outcome[propertyName]);\n\n                        //if _id is undefined then\n                        if (_id === undefined) {\n                            return false;\n                        }\n\n                        //_id is not an array then\n                        if (_id.constructor !== Array) {\n                            _id = [_id];\n                        }\n                        _id = _id.sort();\n\n                        return _id;\n                    }\n\n                    _id = [];\n\n                    outcome.forEach(function (value) {\n                        if (value[propertyName] !== undefined) {\n                            value[propertyName].forEach(function (propertyValue) {\n                                if (_id.indexOf(propertyValue) === -1) {\n                                    _id.push(propertyValue);\n                                }\n                            });\n                        }\n                    });\n\n                    _id = _id.sort();\n\n                    if (_id.length === 0) {\n                        return false;\n                    }\n\n                    return _id;\n\n                };\n\n                //function sets outcome value by setting with Relation property or relational table\n                //and sets checks if the relation exists in main outcome\n                withRelationObject.setOutcome = function (outcome, withTableName, propertyName, relationsData, isFind) {\n                    var tableSchema = self.tables.filter(function (tableObject) {\n                        return (tableObject.name === withTableName);\n                    })[0];\n\n                    if (isFind) {\n                        outcome.Relations = outcome.Relations || {};\n                        outcome.Relations[withTableName] = [];\n                        relationsData.forEach(function (relationData) {\n                            if (outcome[propertyName].indexOf(relationData[tableSchema.fields.keyPathField]) > 0) {\n                                outcome.Relations[withTableName].push(relationData);\n                            }\n                        });\n                        return outcome;\n                    }\n\n                    outcome.forEach(function (outcomeData) {\n                        outcomeData.Relations = outcomeData.Relations || {};\n                        outcomeData.Relations[withTableName] = [];\n\n                        relationsData.forEach(function (relationData) {\n\n                            if (outcomeData[propertyName] === undefined) {\n                                return false;\n                            }\n\n                            if (outcomeData[propertyName].indexOf(relationData[tableSchema.fields.keyPathField]) >= 0) {\n                                outcomeData.Relations[withTableName].push(relationData);\n                            }\n                        });\n                    });\n                    return outcome;\n                };\n\n                /**\n                 * private : function calls relation tables and fetches their data\n                 * @param  {[type]}  resolve           [description]\n                 * @param  {[type]}  reject            [description]\n                 * @param  {array/object}  outcome           [contains main table record(s)]\n                 * @param  {object}  objectStoreTables [with tables in transaction mode]\n                 * @param  {Boolean} isFind            [true for find condition]\n                 */\n                withRelationObject.getWithAllData = function (resolve, reject, outcome, objectStoreTables, isFind) {\n                    //setting default value for isFind\n                    isFind = (isFind === undefined) ? false : isFind;\n\n                    var withTablesCount, relationNames;\n\n                    relationNames = Object.keys(objectStoreTables); //getting relational table names\n                    withTablesCount = relationNames.length;\n\n                    var currentCount = 0;\n\n                    //for each relational table\n                    relationNames.forEach(function (withTableName) {\n                        var _id;\n                        //retrieving relation values from main table\n                        _id = withRelationObject.getRelationData(outcome, isFind, model.originalWithRelation[withTableName].field);\n\n                        //if main table has no relation values then setting Relation status that relational table as empty array\n                        if (_id === false) {\n                            outcome = withRelationObject.setOutcome(outcome, withTableName, model.originalWithRelation[withTableName].field, [], isFind);\n                            currentCount = currentCount + 1;\n\n                            if (currentCount === withTablesCount) {\n                                resolve(outcome);\n                            }\n                            return false;\n                        }\n\n                        var currentOutcome = [];\n                        var hasFilter = false;\n\n                        //if filter was set in relation then setting hasFilter flag\n                        if (typeof model.originalWithRelation[withTableName].filter === 'function') {\n                            hasFilter = true;\n                        }\n\n                        //opening relational table and fetching data\n                        objectStoreTables[withTableName].openCursor(self.keyRange.bound(_id[0], _id[(_id.length - 1)])).onsuccess = function (event) {\n                            try {\n\n                                var cursor = event.target.result;\n                                if (cursor) {\n\n                                    //if relation has filter\n                                    if (hasFilter) {\n                                        if (model.originalWithRelation[withTableName].filter(cursor.value) !== true) {\n                                            cursor.continue();\n                                            return false;\n                                        }\n                                    }\n\n                                    if (!self.helper.whereIn(cursor.key, _id, false)) {\n                                        cursor.continue();\n                                        return false;\n                                    }\n\n                                    currentOutcome.push(cursor.value);\n                                    cursor.continue();\n\n                                } else {\n                                    //when traversing is done\n                                    outcome = withRelationObject.setOutcome(outcome, withTableName, model.originalWithRelation[withTableName].field, currentOutcome, isFind);\n\n                                    currentCount = currentCount + 1;\n\n                                    //when all of the relation tables have completed traversing then resolving\n                                    if (currentCount === withTablesCount) {\n                                        resolve(outcome);\n                                    }\n                                }\n                            } catch (exception) {\n                                transaction.abort();\n                                reject(exception);\n                            }\n                        };\n\n                        //case or error of in relation object store\n                        objectStoreTables[withTableName].openCursor(self.keyRange.bound(_id[0], _id[(_id.length - 1)])).onerror = function (e) {\n                            transaction.abort();\n                            reject(e);\n                        };\n                    });\n\n                };\n\n                //function : calculates aggregate of sum against all sum set\n                aggregateObject.getSums = function (outcome, result) {\n                    if (model.sums.length === 0) {\n                        return outcome;\n                    }\n\n                    outcome.sums = outcome.sums || {};\n\n                    model.sums.forEach(function (property) {\n                        outcome.sums[property] = (outcome.sums[property] === undefined) ? 0 : outcome.sums[property];\n                        var value = self.helper.getPropertyValue(property, result);\n                        if (typeof value === 'number') {\n                            outcome.sums[property] = outcome.sums[property] + value;\n                        }\n                    });\n\n                    return outcome;\n                };\n\n                //function : calculates aggregate of min against all min set\n                aggregateObject.getMins = function (outcome, result) {\n                    if (model.mins.length === 0) {\n                        return outcome;\n                    }\n\n                    outcome.mins = outcome.mins || {};\n\n                    model.mins.forEach(function (property) {\n                        var value = self.helper.getPropertyValue(property, result);\n\n                        if (value === undefined) {\n                            return false;\n                        }\n\n                        outcome.mins[property] = (outcome.mins[property] === undefined) ? value : outcome.mins[property];\n\n                        outcome.mins[property] = self.helper.minValue(outcome.mins[property], value);\n                    });\n\n                    return outcome;\n                };\n\n                //function : calculates aggregate of max against all max set\n                aggregateObject.getMaxs = function (outcome, result) {\n                    if (model.mins.length === 0) {\n                        return outcome;\n                    }\n\n                    outcome.maxs = outcome.maxs || {};\n\n                    model.maxs.forEach(function (property) {\n                        var value = self.helper.getPropertyValue(property, result);\n\n                        if (value === undefined) {\n                            return false;\n                        }\n\n                        outcome.maxs[property] = (outcome.maxs[property] === undefined) ? value : outcome.maxs[property];\n\n                        outcome.maxs[property] = self.helper.maxValue(outcome.maxs[property], value);\n                    });\n\n                    return outcome;\n                };\n\n                //function : calculates aggregate of averages against all averages set\n                aggregateObject.getAverages = function (outcome, resultOrCount, finalCalculation) {\n                    if (model.averages.length === 0) {\n                        return outcome;\n                    }\n\n                    outcome.averages = outcome.averages || {};\n\n                    model.averages.forEach(function (property) {\n                        if (finalCalculation === true) {\n                            outcome.averages[property] = outcome.averages[property] / resultOrCount;\n                            return false;\n                        }\n\n                        outcome.averages[property] = (outcome.averages[property] === undefined) ? 0 : outcome.averages[property];\n\n                        var value = self.helper.getPropertyValue(property, resultOrCount);\n\n                        if (typeof value === 'number') {\n                            outcome.averages[property] = outcome.averages[property] + value;\n                        }\n                    });\n\n                    return outcome;\n                };\n\n                //function : calculates aggregate of custom functions against all custom functions set\n                aggregateObject.getCustoms = function (outcome, resultOrCount, finalCalculation) {\n                    if (model.customs.length === 0) {\n                        return outcome;\n                    }\n\n                    outcome.customs = outcome.customs || {};\n\n                    model.customs.forEach(function (customObject) {\n                        if (finalCalculation === true && customObject.endCallback !== undefined) {\n                            outcome.customs[customObject.name] = customObject.endCallback(outcome[customObject.name], resultOrCount);\n                            return false;\n                        }\n\n                        outcome.customs[customObject.name] = (outcome.customs[customObject.name] === undefined) ? 0 : outcome.customs[customObject.name];\n\n                        var value = self.helper.getPropertyValue(customObject.name, resultOrCount);\n\n                        outcome.customs[customObject.name] = customObject.callback(outcome.customs[customObject.name], value);\n                    });\n\n                    return outcome;\n                };\n\n                //private : function returns array of table names to perform transaction on\n                function _getTransactionTables() {\n                    var transactionTables = [];\n                    //default pushing main table name\n                    transactionTables.push(table.name);\n\n                    if (model.hasWith) {\n                        //pushing relation table names\n                        var withTables = Object.keys(model.withTables);\n                        withTables.forEach(function (withTable) {\n                            transactionTables.push(withTable);\n                        });\n\n                    }\n\n                    return transactionTables;\n                }\n\n                //private : wrapper for calling default getAll with callback for success\n                function _get(callback, readwrite) {\n                    //setting read write status flag of transaction\n                    var write = (readwrite === undefined || readwrite === false || readwrite === null) ? 'readonly' : 'readwrite';\n\n                    var transactionTables = [];\n                    var relations = {};\n\n                    return $q(function (resolve, reject) {\n                        self.openConnection.then(function (event) {\n                            try {\n                                var db = event.target.result;\n                                //opening transaction\n                                transactionTables = _getTransactionTables();\n                                transaction = db.transaction(transactionTables, write);\n\n                                //if model has with relation\n                                if (model.hasWith) {\n                                    transactionTables.splice(0, 1);\n                                    transactionTables.forEach(function (tableName) {\n                                        relations[tableName] = transaction.objectStore(tableName);\n                                    });\n\n                                }\n\n                                objectStore = transaction.objectStore(table.name);\n\n                                //if index is defined then adding index to object store\n                                if (model.index !== null) {\n                                    objectStore = objectStore.index(model.index);\n                                }\n\n                                objectStore = objectStore.openCursor(model.bound, model.traverse);\n\n                                //on success giving callback with promise and relation data\n                                objectStore.onsuccess = function (event) {\n                                    try {\n                                        callback(event, resolve, reject, relations);\n\n                                    } catch (exception) {\n                                        transaction.abort();\n                                        reject(exception);\n                                    }\n                                };\n\n                                objectStore.onerror = function (error) {\n                                    transaction.abort();\n                                    reject(error);\n                                };\n\n                                transaction.onerror = function (error) {\n                                    reject(error);\n                                };\n\n                            } catch (exception) {\n                                reject(exception);\n                            }\n\n                        }).catch(function (error) {\n                            reject(error);\n                        });\n                    });\n                }\n\n                //private : function returns new object value to be updated with timestamps\n                function _updateValue(result, data, hasTimeStamp) {\n                    hasTimeStamp = (hasTimeStamp === undefined) ? false : hasTimeStamp;\n\n                    var newValue = angular.copy(result);\n\n                    var properties = Object.keys(data);\n                    properties.forEach(function (property) {\n                        newValue[property] = data[property];\n                    });\n\n                    if (table.hasTimeStamp && !hasTimeStamp) {\n                        newValue.updatedAt = Date.parse(Date());\n                    }\n\n                    if (hasTimeStamp) {\n                        newValue.updatedAt = Date.parse(Date());\n                    }\n\n                    return newValue;\n                }\n\n                //private : function updates the relations indexes by adding new values\n                withRelationObject.update = function (record, data) {\n                    //retrieving properties to be updated\n                    var properties = Object.keys(data);\n\n                    properties.forEach(function (property) {\n                        //if property in main record is undefined\n                        if (record[property] === undefined) {\n                            record[property] = [];\n                        }\n                        data[property].forEach(function (relation) {\n                            //checking if relation already exists if not then adding\n\n                            //if relation is greater than or equal to zero then adding the relation\n                            if (relation >= 0) {\n                                if (record[property].indexOf(relation) === -1) {\n                                    record[property].push(relation);\n                                }\n                            } else {\n                                //else removing relation\n                                var index = record[property].indexOf(relation * (-1));\n                                if (index !== -1) {\n                                    record[property].splice(index, 1);\n                                }\n                            }\n                        });\n                    });\n\n                    return record;\n                };\n\n                /**\n                 * private : function adds relation id to related tables. If many relation is set then also adds the relation tables record ids to the main table for creating many to many\n                 * @param {resolve} resolve           [resolves the promise]\n                 * @param {reject} reject            [rejects the promise]\n                 * @param {integer} outcome           [contains newly created records key path value]\n                 * @param {object} objectStoreTables [with tables in transaction mode]\n                 * @param {IDBTransaction} transaction       [transaction instance]\n                 */\n                withRelationObject.add = function (resolve, reject, outcome, objectStoreTables, transaction) {\n                    var withTablesCount, relationNames;\n\n                    relationNames = Object.keys(objectStoreTables); //getting relational table names\n                    withTablesCount = relationNames.length;\n\n                    var currentCount = 0;\n                    var manyOutcome = {};\n\n                    relationNames.forEach(function (withTableName) {\n                        var hasFilter = false; //setting if with table has filter\n                        var isMany = false; //if main table is in many to many relationship\n                        var many = [];\n\n                        //if filter was set in relation then setting hasFilter flag\n                        if (typeof model.originalWithRelation[withTableName].filter === 'function') {\n                            hasFilter = true;\n                        }\n\n                        //setting flag for many to many\n                        if (typeof model.originalWithRelation[withTableName].many === 'object') {\n                            if (model.originalWithRelation[withTableName].many.isMany === true) {\n                                isMany = true;\n                            }\n                        }\n\n                        //opening cursor on relation table\n                        objectStoreTables[withTableName].openCursor().onsuccess = function (event) {\n                            var cursor = event.target.result;\n\n                            if (cursor) {\n                                var newValue = _updateValue(cursor.value, {}, true);\n\n                                //if relation has filter\n                                if (hasFilter) {\n                                    if (model.originalWithRelation[withTableName].filter(angular.copy(cursor.value)) !== true) {\n                                        cursor.continue();\n                                        return;\n                                    }\n                                }\n\n                                //if property of relation is undefined then creating one as an array\n                                if (newValue[model.originalWithRelation[withTableName].field] === undefined) {\n                                    newValue[model.originalWithRelation[withTableName].field] = [];\n                                }\n\n                                //if relation does not have the index then adding it to list\n                                if (newValue[model.originalWithRelation[withTableName].field].indexOf(outcome._id) === -1) {\n                                    newValue[model.originalWithRelation[withTableName].field].push(outcome._id);\n\n                                    //case for many to many\n                                    if (isMany) {\n                                        many.push(cursor.value._id);\n                                    }\n                                }\n\n                                cursor.update(newValue);\n                                cursor.continue();\n\n                            } else {\n                                currentCount = currentCount + 1;\n\n                                //case for may then adding many relation to newly created object\n                                if (isMany === true) {\n                                    manyOutcome[model.originalWithRelation[withTableName].many.field] = many;\n                                }\n\n                                if (currentCount === withTablesCount) {\n\n                                    //if is many relationship then also updating current outcome value\n                                    if (isMany) {\n                                        outcome = _updateValue(outcome, manyOutcome);\n\n                                        var newObjectStore = transaction.objectStore(table.name);\n\n                                        newObjectStore.put(outcome).onsuccess = function () {\n                                            resolve(outcome);\n                                        };\n\n                                        newObjectStore.onerror = function (error) {\n                                            transaction.abort();\n                                            reject(error);\n                                        };\n\n                                    } else {\n                                        resolve(outcome);\n                                    }\n                                }\n                            }\n                        };\n\n                        objectStoreTables[withTableName].openCursor().onerror = function (error) {\n                            transaction.abort();\n                            reject(error);\n                        };\n                    });\n                };\n\n                /**\n                 * private : function delete the record relation to other tables\n                 * @param  {resolve}  resolve           [resolves the promise]\n                 * @param  {reject}  reject            [reject the promise]\n                 * @param  {array/integer}  value             [contains the id(s) of records delete]\n                 * @param  {object}  objectStoreTables [with tables in transaction mode]\n                 * @param  {Boolean} isDestroy         [for destroy mode]\n                 */\n                withRelationObject.destroy = function (resolve, reject, value, objectStoreTables, isDestroy, count) {\n                    isDestroy = (isDestroy === undefined) ? false : isDestroy;\n                    var withTablesCount, relationNames;\n\n                    relationNames = Object.keys(objectStoreTables); //getting relational table names\n                    withTablesCount = relationNames.length;\n\n                    var currentCount = 0;\n                    var bound;\n\n                    //setting bound values for cursor location\n                    if (isDestroy) {\n                        value = value.sort();\n                        bound = self.keyRange.bound(value[0], value[(value.length - 1)]);\n                    } else {\n                        bound = self.keyRange.only(value);\n                    }\n\n                    relationNames.forEach(function (withTableName) {\n                        objectStoreTables[withTableName].index(model.originalWithRelation[withTableName].field).openCursor(bound).onsuccess = function (event) {\n                            try {\n                                var cursor = event.target.result;\n                                if (cursor) {\n                                    var newValue = _updateValue(cursor.value, {}, true);\n                                    if (newValue[model.originalWithRelation[withTableName].field] === undefined) {\n                                        cursor.continue();\n                                        return;\n                                    }\n\n                                    var index;\n                                    if (isDestroy) {\n                                        value.forEach(function (_id) {\n                                            index = newValue[model.originalWithRelation[withTableName].field].indexOf(_id);\n\n                                            if (index !== -1) {\n                                                newValue[model.originalWithRelation[withTableName].field].splice(index, 1);\n                                            }\n                                        });\n                                    } else {\n                                        index = newValue[model.originalWithRelation[withTableName].field].indexOf(value);\n\n                                        if (index === -1) {\n                                            cursor.continue();\n                                            return;\n                                        }\n\n                                        newValue[model.originalWithRelation[withTableName].field].splice(index, 1);\n                                    }\n\n\n                                    cursor.update(newValue);\n                                    cursor.continue();\n\n                                } else {\n\n                                    currentCount = currentCount + 1;\n\n                                    if (currentCount === withTablesCount) {\n                                        resolve(count);\n                                    }\n                                }\n                            } catch (exception) {\n                                transaction.abort();\n                                reject(exception);\n                            }\n\n                        };\n\n                        objectStoreTables[withTableName].onerror = function (error) {\n                            transaction.abort();\n                            reject(error);\n                        };\n                    });\n                };\n\n                //finds a single record according to value set (not case sensitive)\n                model.find = function () {\n\n                    var getId = $q(function (resolve, reject) {\n                        self.openConnection.then(function (event) {\n                            var transactionTables = [];\n                            var relations = {};\n\n                            try {\n                                var db = event.target.result;\n\n                                transactionTables = _getTransactionTables();\n                                transaction = db.transaction(transactionTables);\n\n                                if (model.hasWith) {\n                                    transactionTables.splice(0, 1);\n                                    transactionTables.forEach(function (withTableName) {\n                                        relations[withTableName] = transaction.objectStore(withTableName);\n                                    });\n                                }\n\n                                objectStore = transaction.objectStore(table.name);\n\n                                //if index is set then searching on the index\n                                if (model.index !== null) {\n                                    objectStore = objectStore.index(model.index);\n                                }\n\n                                objectStore = objectStore.get(model.bound);\n                                objectStore.onsuccess = function (record) {\n                                    try {\n                                        //if no record was found then resolving\n                                        if (record === undefined) {\n                                            resolve(record);\n                                            return false;\n                                        }\n\n                                        //if with relationship was defined then\n                                        if (model.hasWith) {\n                                            withRelationObject.getWithAllData(resolve, reject, record.target.result, relations, true);\n                                            return false;\n                                        }\n\n                                        resolve(record.target.result);\n\n                                    } catch (exception) {\n                                        transaction.abort();\n                                        reject(exception);\n                                    }\n                                };\n\n                                objectStore.onerror = function (error) {\n                                    transaction.abort();\n                                    reject(error);\n                                };\n\n                                transaction.onerror = function (error) {\n                                    reject(error);\n                                };\n\n                            } catch (exception) {\n                                reject(exception);\n                            }\n\n\n                        }).catch(function (error) {\n                            reject(error);\n                        });\n\n                    });\n\n                    return getId;\n                };\n\n                //function adds single record\n                model.add = function (data) {\n\n                    var add = $q(function (resolve, reject) {\n                        self.openConnection.then(function (event) {\n\n                            var transactionTables = [];\n                            var relations = {};\n\n                            try {\n                                var db = event.target.result;\n\n                                transactionTables = _getTransactionTables();\n                                transaction = db.transaction(transactionTables, \"readwrite\");\n\n                                if (model.hasWith) {\n                                    transactionTables.splice(0, 1);\n                                    transactionTables.forEach(function (withTableName) {\n                                        relations[withTableName] = transaction.objectStore(withTableName);\n                                    });\n                                }\n\n                                objectStore = transaction.objectStore(table.name);\n                                if (table.hasTimeStamp) {\n                                    data.updatedAt = Date.parse(Date());\n                                    data.createdAt = Date.parse(Date());\n                                }\n                                objectStore = objectStore.add(data);\n\n                                objectStore.onsuccess = function (event) {\n                                    try {\n                                        var result;\n                                        result = data;\n\n                                        //adding key path value to the data object after adding\n                                        result[table.fields.keyPathField] = event.target.result;\n\n                                        if (model.hasWith) {\n                                            withRelationObject.add(resolve, reject, result, relations, transaction);\n                                        } else {\n                                            resolve(result);\n\n                                        }\n\n                                    } catch (exception) {\n                                        transaction.abort();\n                                        reject(exception);\n                                    }\n\n                                };\n\n                                objectStore.onerror = function (error) {\n                                    transaction.abort();\n                                    reject(error);\n                                };\n\n                                transaction.onerror = function (event) {\n                                    reject(event.srcElement.error);\n                                };\n                            } catch (exception) {\n                                reject(exception);\n                            }\n\n                        }).catch(function (error) {\n                            reject(error);\n                        });\n                    });\n\n                    return add;\n                };\n\n                //add multiple data at once in single transaction\n                model.addMultiple = function (data) {\n                    var outcome = [];\n                    var count = data.length; //total no of records to be inserted\n                    var inserted = 0; //no of records inserted\n\n                    var add = $q(function (resolve, reject) {\n\n                        self.openConnection.then(function (event) {\n                            try {\n\n                                var db = event.target.result;\n                                transaction = db.transaction([table.name], \"readwrite\");\n\n                                try {\n\n                                    objectStore = transaction.objectStore(table.name);\n                                    //for each record\n                                    data.forEach(function (toAddData) {\n\n                                        //adding time stamps if allowed\n                                        if (table.hasTimeStamp) {\n                                            toAddData.updatedAt = Date.parse(Date());\n                                            toAddData.createdAt = Date.parse(Date());\n                                        }\n\n                                        //single add instance\n                                        objectStore.add(toAddData).onsuccess = function (event) {\n                                            try {\n                                                var result;\n                                                result = data[inserted];\n\n                                                //adding newly inserted key path value to the object\n                                                result[table.fields.keyPathField] = event.target.result;\n\n                                                outcome.push(result);\n                                                inserted = inserted + 1;\n\n                                                //if inserted count is equal to total no of records then resolving\n                                                if (inserted === count) {\n                                                    resolve(outcome);\n                                                }\n                                            } catch (exception) {\n                                                transaction.abort();\n                                                reject(exception);\n                                            }\n\n                                        };\n                                    });\n\n                                } catch (exception) {\n                                    transaction.abort();\n                                    reject(exception);\n                                    return;\n                                }\n\n\n                                transaction.onerror = function (event) {\n                                    reject(event.srcElement.error);\n                                };\n                            } catch (exception) {\n                                reject(exception);\n                            }\n\n                        }).catch(function (error) {\n                            reject(error);\n                        });\n\n                    });\n\n                    return add;\n                };\n\n                //function is default getAll function retrieves all data\n                model.getAll = function () {\n                    var outcome = [];\n\n                    var getId = _get(function (event, resolve, reject, withTables) {\n\n                        var result = event.target.result;\n\n                        if (result) {\n                            if (!_checkResult(result)) {\n                                result.continue();\n                                return false;\n                            }\n\n                            outcome.push(result.value);\n                            result.continue();\n\n\n                        } else {\n                            if (outcome.length === 0) {\n                                resolve(outcome);\n                                return false;\n                            }\n\n                            //if model has relations then resolving when relation transactions are complete else resolving\n                            if (model.hasWith) {\n                                withRelationObject.getWithAllData(resolve, reject, outcome, withTables);\n                                return false;\n                            }\n\n                            resolve(outcome);\n\n                        }\n                    });\n                    return getId;\n                };\n\n                //wrapper function firing default put on the indexed db\n                model.put = function (data) {\n                    var put = $q(function (resolve, reject) {\n                        self.openConnection.then(function (event) {\n                            try {\n                                var db = event.target.result;\n                                transaction = db.transaction([table.name], \"readwrite\");\n                                objectStore = transaction.objectStore(table.name);\n\n                                if (table.hasTimeStamp) {\n                                    data.updatedAt = Date.parse(Date());\n\n                                    if (data.createdAt === undefined) {\n                                        data.createdAt = Date.parse(Date());\n                                    }\n                                }\n\n                                if (data[table.fields.keyPathField] === undefined) {\n                                    transaction.abort();\n                                    reject(new Error(\"KeyPath field not provied for update\"));\n                                }\n\n                                //firing put method\n                                objectStore = objectStore.put(data);\n\n                                objectStore.onsuccess = function (event) {\n                                    try {\n                                        //adding newly/existing key path value to the object\n                                        data[table.keyPathField] = event.target.result;\n                                        resolve(data);\n\n                                    } catch (exception) {\n                                        transaction.abort();\n                                        reject(exception);\n                                    }\n                                };\n\n                                objectStore.onerror = function (error) {\n                                    transaction.abort();\n                                    reject(error);\n                                };\n\n                                transaction.onerror = function (error) {\n                                    reject(error);\n                                };\n\n                            } catch (exception) {\n                                reject(exception);\n                            }\n\n                        }).catch(function (error) {\n                            reject(error);\n                        });\n\n                    });\n\n                    return put;\n                };\n\n                //function fires update method on the model\n                model.update = function (data) {\n                    if (typeof data !== 'object') {\n                        throw \"Data must be type of object\";\n                    }\n\n                    var count = 0;\n                    var update = _get(function (event, resolve) {\n                        var result = event.target.result;\n                        var newValue;\n\n                        if (result) {\n\n\n                            if (!_checkResult(result)) {\n                                result.continue();\n                                return false;\n                            }\n\n                            newValue = _updateValue(result.value, data);\n\n                            //setting with relation data to the record as well\n                            if (model.hasWith) {\n                                newValue = withRelationObject.update(newValue, model.originalWithRelation);\n                            }\n\n                            result.update(newValue);\n                            count = count + 1;\n                            result.continue();\n\n\n                        } else {\n                            resolve(count);\n                        }\n                    }, true);\n\n                    return update;\n                };\n\n                //wrapper for default delete in indexeddb\n                model.delete = function (value) {\n\n                    if (value === undefined) {\n                        throw \"Empty value provided for deleting\";\n                    }\n                    var objectStoreDelete;\n                    var deleteId = $q(function (resolve, reject) {\n                        self.openConnection.then(function (event) {\n                            try {\n\n                                var db = event.target.result;\n                                var relations = {};\n\n                                var transactionTables = _getTransactionTables();\n                                transaction = db.transaction(transactionTables, 'readwrite');\n\n                                if (model.hasWith) {\n                                    transactionTables.splice(0, 1);\n                                    transactionTables.forEach(function (withTableName) {\n                                        relations[withTableName] = transaction.objectStore(withTableName);\n                                    });\n                                }\n\n                                objectStore = transaction.objectStore(table.name);\n                                objectStoreDelete = transaction.objectStore(table.name);\n\n                                objectStore.get(value).onsuccess = function (record) {\n                                    if (record.target.result === undefined) {\n                                        resolve(0);\n                                        return false;\n                                    }\n                                    objectStoreDelete = objectStoreDelete.delete(value);\n\n                                    objectStoreDelete.onsuccess = function () {\n                                        try {\n                                            if (model.hasWith) {\n                                                withRelationObject.destroy(resolve, reject, value, relations, 1);\n                                            } else {\n                                                resolve(1);\n                                            }\n                                        } catch (exception) {\n                                            transaction.abort();\n                                            reject(exception);\n                                        }\n\n                                    };\n\n                                    objectStoreDelete.onerror = function (error) {\n                                        transaction.abort();\n                                        reject(error);\n                                    };\n                                };\n\n\n                                transaction.onerror = function (error) {\n                                    reject(error);\n                                };\n\n                            } catch (exception) {\n                                reject(exception);\n                            }\n\n                        }).catch(function (error) {\n                            reject(error);\n                        });\n                    });\n\n                    return deleteId;\n                };\n\n                //function to delete on cursor location\n                model.destroy = function () {\n                    var count = 0;\n                    var deletedIds = [];\n\n                    var del = _get(function (event, resolve, reject, relations) {\n                        var result = event.target.result;\n\n                        if (result) {\n                            if (!_checkResult(result)) {\n                                result.continue();\n                                return false;\n                            }\n\n                            deletedIds.push(result.value[table.fields.keyPathField]);\n                            result.delete();\n\n                            count = count + 1;\n                            result.continue();\n\n                        } else {\n\n                            if (model.hasWith) {\n                                withRelationObject.destroy(resolve, reject, deletedIds, relations, true, count);\n                            } else {\n                                resolve(count);\n                            }\n                        }\n                    }, true);\n\n                    return del;\n                };\n\n\n\n                /**\n                 * Class : Function contains definition for aggregation\n                 */\n                function CreateAggregate() {\n                    var aggregate = this;\n\n                    //function counts the number of records\n                    aggregate.count = function () {\n                        var count = 0;\n\n                        var c = _get(function (event, resolve) {\n                            var result = event.target.result;\n\n                            //if record exists\n                            if (result) {\n\n                                //passing result through filter\n                                if (!_checkResult(result)) {\n                                    result.continue();\n                                    return false;\n                                }\n\n                                count = count + 1;\n                                result.continue();\n                            } else {\n                                resolve(count);\n                            }\n\n                        });\n\n                        return c;\n                    };\n\n                    //function calculates sum of records against the property if its value is numeric\n                    aggregate.sum = function (property) {\n                        var value;\n                        var sum = 0;\n\n                        //if property is undefined then taking model index or the keyPath field\n                        if (property === undefined) {\n                            property = (model.index === null) ? table.fields.keyPathField : model.index;\n                        }\n\n                        var c = _get(function (event, resolve) {\n                            var result = event.target.result;\n\n                            //if record exists\n                            if (result) {\n\n                                //passing result through filter\n                                if (!_checkResult(result)) {\n                                    result.continue();\n                                    return false;\n                                }\n\n                                //getting the value at the property\n                                value = self.helper.getPropertyValue(property, result.value);\n\n                                if (typeof value === 'number') {\n                                    sum = sum + value;\n                                }\n                                result.continue();\n\n                            } else {\n                                resolve(sum);\n                            }\n\n                        });\n\n                        return c;\n                    };\n\n                    //function retrieves the max value at the property\n                    aggregate.max = function (property) {\n                        var value;\n                        var max = null;\n\n                        //if property is undefined then taking model index or the keyPath field\n                        if (property === undefined) {\n                            property = (model.index === null) ? table.fields.keyPathField : model.index;\n                        }\n\n                        var m = _get(function (event, resolve) {\n                            var result = event.target.result;\n\n                            //if record exists\n                            if (result) {\n\n                                //passing result through filter\n                                if (!_checkResult(result)) {\n                                    result.continue();\n                                    return false;\n                                }\n\n                                value = self.helper.getPropertyValue(property, result.value);\n\n                                //if pointer is at first record then setting the value of max as that else checking\n                                if (value !== undefined) {\n                                    max = (max === null) ? value : self.helper.maxValue(max, value);\n                                }\n                                result.continue();\n\n                            } else {\n                                resolve(max);\n                            }\n\n                        });\n\n                        return m;\n                    };\n\n                    //function calculates the min value of property\n                    aggregate.min = function (property) {\n                        var value;\n                        var min = null;\n\n                        //if property is undefined then taking model index or the keyPath field\n                        if (property === undefined) {\n                            property = (model.index === null) ? table.fields.keyPathField : model.index;\n                        }\n\n                        var m = _get(function (event, resolve) {\n                            var result = event.target.result;\n\n                            //if record exists\n                            if (result) {\n\n                                //passing result through filter\n                                if (!_checkResult(result)) {\n                                    result.continue();\n                                    return false;\n                                }\n\n                                value = self.helper.getPropertyValue(property, result.value);\n\n                                //if pointer is at first record then setting the value of min as that else checking\n                                if (value !== undefined) {\n                                    min = (min === null) ? value : self.helper.minValue(min, value);\n                                }\n                                result.continue();\n\n                            } else {\n                                resolve(min);\n                            }\n\n                        });\n\n                        return m;\n                    };\n\n                    aggregate.average = function (property) {\n                        var value;\n                        var average = 0,\n                            sum = 0,\n                            count = 0;\n\n                        if (property === undefined) {\n                            property = (model.index === null) ? table.fields.keyPathField : model.index;\n                        }\n\n                        var a = _get(function (event, resolve) {\n                            var result = event.target.result;\n\n                            //if record exists\n                            if (result) {\n\n                                //passing result through filter\n                                if (!_checkResult(result)) {\n                                    result.continue();\n                                    return false;\n                                }\n\n                                count++;\n\n                                value = self.helper.getPropertyValue(property, result.value);\n                                if (typeof value === 'number') {\n                                    sum = sum + value;\n                                }\n\n                                result.continue();\n\n                            } else {\n                                average = (sum === 0 && count === 0) ? 0 : sum / count;\n                                resolve(average);\n                            }\n\n                        });\n\n                        return a;\n                    };\n\n                    aggregate.custom = function (callback, endCallback) {\n                        if (typeof callback !== 'function') {\n                            throw \"Parameter passed to custom aggregate must be of function type\";\n                        }\n\n                        var outcome = 0;\n\n                        var cust = _get(function (event, resolve, reject) {\n                            var result = event.target.result;\n\n                            if (result) {\n                                //passing result through filter\n                                if (!_checkResult(result)) {\n                                    result.continue();\n                                    return false;\n                                }\n\n                                try {\n                                    outcome = callback(outcome, angular.copy(result.value));\n                                } catch (exception) {\n                                    transaction.abort();\n                                    reject(exception);\n                                    return false;\n                                }\n\n                                result.continue();\n\n                            } else {\n                                if (typeof endCallback === 'function') {\n                                    outcome = endCallback(outcome);\n                                }\n\n                                resolve(outcome);\n                            }\n                        });\n\n                        return cust;\n                    };\n                }\n\n                model.getAggregate = function () {\n                    var count = 0;\n                    var outcome = {};\n\n                    var ag = _get(function (event, resolve, reject) {\n                        var result = event.target.result;\n\n                        if (result) {\n                            //passing result through filter\n                            if (!_checkResult(result)) {\n                                result.continue();\n                                return false;\n                            }\n\n                            count = count + 1;\n\n                            try {\n                                outcome = aggregateObject.getSums(outcome, result.value);\n                                outcome = aggregateObject.getAverages(outcome, result.value, false);\n                                outcome = aggregateObject.getMins(outcome, result.value);\n                                outcome = aggregateObject.getMaxs(outcome, result.value);\n                                outcome = aggregateObject.getCustoms(outcome, result.value, false);\n\n                            } catch (exception) {\n                                reject(exception);\n                            }\n\n\n                            result.continue();\n                        } else {\n                            outcome = aggregateObject.getAverages(outcome, count, true);\n                            outcome = aggregateObject.getCustoms(outcome, count, true);\n                            resolve(outcome);\n                        }\n                    });\n\n                    return ag;\n                };\n\n                model.aggregate = new CreateAggregate();\n\n            }\n\n\n            //function sets the index configure values(unique/multientry)\n            function _getFieldConfig(field) {\n                var config = {};\n                if (field.hasOwnProperty('unique')) {\n                    if (field.unique) {\n                        config.unique = true;\n                    }\n                }\n\n                if (field.hasOwnProperty('multiEntry')) {\n                    if (field.multiEntry) {\n                        config.multiEntry = true;\n                    }\n                }\n                return config;\n            }\n\n            //function sets keyPathValue if not provided\n            function _getIndexValue(field) {\n                if (field.keyPathValue === undefined) {\n                    return field.name;\n                }\n\n                return field.keyPathValue;\n            }\n\n            function _createModelInstance(db, table) {\n                var objectStore;\n                if (db.objectStoreNames.contains(table.name)) {\n                    objectStore = db.transaction([table.name]).objectStore(table.name);\n\n                    //checking if table given exists in indexeddb\n                    if (objectStore.keyPath !== table.fields.keyPathField) {\n                        table.fields.keyPathField = objectStore.keyPath;\n                    }\n\n                    self.models[table.name] = {};\n                    //setting getter instance of object as new CreateModel instance\n                    Object.defineProperty(self.models, table.name, {\n                        get: function () {\n                            return new CreateModel(table);\n                        }\n                    });\n                }\n            }\n\n            /**\n             * Private : function creates tables when upgrade function is fired\n             * @param  {event.target.result} db [it of result of event of upgradedneeded]\n             */\n            function _createTables(target) {\n                var config, db, transaction;\n                db = target.result;\n                transaction = target.transaction;\n\n                self.tables.forEach(function (table) {\n                    var objectStore;\n\n                    //if table does not exist then creating it\n                    if (!db.objectStoreNames.contains(table.name)) {\n\n                        //setting auto increment to keyPath\n                        objectStore = db.createObjectStore(table.name, {\n                            keyPath: table.fields.keyPathField,\n                            autoIncrement: true\n                        });\n\n                        //creating other fields/indexes\n                        table.fields.other.forEach(function (field) {\n                            var indexValue = _getIndexValue(field);\n                            config = _getFieldConfig(field); //fetching configuration against the index\n                            objectStore.createIndex(field.name, indexValue, config);\n                        });\n\n                    } else {\n                        objectStore = transaction.objectStore(table.name);\n\n                        //creating new fields/indexes\n                        table.fields.other.forEach(function (field) {\n                            var indexValue = _getIndexValue(field);\n                            config = _getFieldConfig(field); //fetching configuration against the index\n                            if (!objectStore.indexNames.contains(field.name)) {\n                                objectStore.createIndex(field.name, indexValue, config);\n                            }\n                        });\n                    }\n\n                    self.models[table.name] = {};\n                    //setting getter instance of object as new CreateModel instance\n                    Object.defineProperty(self.models, table.name, {\n                        get: function () {\n                            return new CreateModel(table);\n                        }\n                    });\n                });\n            }\n\n            //private : function sets the fields(indexes) and keyPath field value of table\n            function _setFields(fields, tableName) {\n                var j, field, keyPath, newFields, fieldNames;\n                keyPath = false;\n                newFields = {};\n                newFields.other = [];\n                fieldNames = [];\n\n                //setting other fields and keyPath Field\n                for (j = fields.length - 1; j >= 0; j--) {\n                    field = fields[j];\n\n                    //validating field properties\n                    if (typeof field.name !== 'string') {\n                        throw \"Field/Index name must be of string type\";\n                    }\n\n                    if (fieldNames.indexOf(field.name) !== -1) {\n                        throw \"Field/Index name already exists\";\n                    }\n\n                    //pushing to feildNames to check further fields of tables\n                    fieldNames.push(field.name);\n\n                    //checking field for keyPath property\n                    if (field.hasOwnProperty('keyPath')) {\n                        if (field.keyPath === true) {\n\n                            //checking if keyPath has already being set\n                            if (keyPath === true) {\n                                throw \"Error multiple keyPath defined in table \" + tableName;\n                            }\n                            //setting keyPath as this field \n                            newFields.keyPathField = field.name;\n                            keyPath = true; //setting keyPath flag as keyPath has been defined\n\n                        } else {\n                            //adding field to other array stating them as indexes\n                            newFields.other.push(field);\n                        }\n                    } else {\n                        //adding field to other array stating them as indexes\n                        newFields.other.push(field);\n                    }\n                }\n\n                //if no keyPath field was set then setting default as '_id'\n                if (!keyPath) {\n                    newFields.keyPathField = '_id';\n                }\n\n                return newFields;\n            }\n\n            //private : function prepares tables for creating them db and to create models against them\n            function _setTables() {\n                var i, table, fields, tableNames;\n                tableNames = [];\n                //for each table\n                for (i = self.tables.length - 1; i >= 0; i--) {\n\n                    table = self.tables[i];\n\n                    //validating table name type\n                    if (typeof table.name !== 'string') {\n                        throw \"Table/ObjectStore name must be of string type\";\n                    }\n\n                    if (tableNames.indexOf(table.name) !== -1) {\n                        throw \"Repeated Table/ObjectStore name \" + table.name;\n                    }\n\n                    //pushing to array to check further table names\n                    tableNames.push(table.name);\n\n                    table.hasTimeStamp = false; //default timestamps value as false\n\n                    //fetching fields data\n                    fields = _setFields(table.fields, table.name);\n                    table.fields = fields;\n\n                    //checking if timestamps property is set\n                    if (table.timeStamps === true) {\n                        table.hasTimeStamp = true; //setting timestamps to be true\n\n                        //checking if indexing on timestamps needs to be done\n                        if (table.indexOnTimeStamps === true) {\n\n                            //creating indexing on timestamps with multientry as configuration\n                            table.fields.other.push({\n                                name: 'updatedAt',\n                                keyPathValue: 'updatedAt',\n                                multiEntry: true\n                            });\n                            table.fields.other.push({\n                                name: 'createdAt',\n                                keyPathValue: 'createdAt',\n                                multiEntry: true\n                            });\n                        }\n                    }\n                }\n            }\n\n            _setTables();\n\n            self.open.then(function (event) {\n                try {\n                    var l, table;\n                    //when database is being upgraded\n                    if (event.type === \"upgradeneeded\") {\n                        _createTables(event.target);\n                    } else {\n                        for (l = self.tables.length - 1; l >= 0; l--) {\n                            table = self.tables[l];\n                            _createModelInstance(event.target.result, table);\n\n                        }\n                    }\n\n                } catch (exception) {\n                    qRej(exception);\n                }\n                qRes(self);\n\n            }).catch(function (event) {\n                qRej(event);\n            });\n\n        }\n\n        return $q(function (res, rej) {\n            var a = new CreateTables(dbName, dbVersion, dbTables, res, rej);\n            return a;\n        });\n    }\n\n    initialize.$inject = ['$q'];\n\n    function setDbName(name) {\n        dbName = name;\n    }\n\n    function setDbTables(tables) {\n        dbTables = tables;\n    }\n\n    function setDbVersion(version) {\n        dbVersion = version;\n    }\n\n\n    return {\n        setDbName: setDbName,\n        setDbVersion: setDbVersion,\n        setDbTables: setDbTables,\n        $get: initialize\n    };\n\n\n}\n\nindexeddbProvider.$inject = ['$windowProvider'];\nangular.module('indexed-db', []);\nangular.module('indexed-db').provider('indexeddb', indexeddbProvider);\n"],"sourceRoot":"/source/"}