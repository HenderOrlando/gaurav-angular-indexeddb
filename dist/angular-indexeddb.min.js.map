/**
 * gaurav-angular-indexeddb - IndexedDB wrapper for Angular JS
 * @version v0.0.1
 * @link https://github.com/gauravgango/gaurav-angular-indexeddb
 * @license MIT
 */
{"version":3,"sources":["angular-indexeddb.js"],"names":["indexeddbProvider","$windowProvider","initialize","$q","CreateDB","name","version","_check","self","indexdb","$window","indexedDB","mozIndexedDB","webkitIndexedDB","msIndexedDB","keyRange","IDBKeyRange","mozIDBKeyRange","webkitIDBKeyRange","msIDBKeyRange","this","open","Promise","resolve","reject","connection","onupgradeneeded","event","onerror","srcElement","error","onsuccess","CreateTables","tables","qRes","qRej","CreateModel","table","_resetModel","model","bound","index","caseInsensitive","hasFilter","filterFunction","whereInValues","whereNotInValues","withTables","hasWith","_getTransactionTables","transactionTables","push","Object","keys","forEach","withTable","_get","callback","readwrite","write","undefined","relations","db","target","result","transaction","splice","tableName","objectStore","openCursor","err","_changeCase","value","toUpper","toUpperCase","toLowerCase","_whereNotIn","outcome","notInCaseInsensitiveArray","resultKey","key","lowerValue","angular","copy","indexOf","_whereIn","count","useCaseInsensitive","_updateValue","data","hasTimeStamp","newValue","properties","property","updatedAt","Date","parse","_whereInUpdate","toUpdate","update","_whereNotInUpdate","_whereInDestroy","deletedIds","toDelete","fields","keyPathField","_wherNotInDestroy","_getWithAllData","objectStoreTables","isFind","length","_id","withTablesCount","relationNames","currentCount","withTableName","originalWithRelation","field","record","d","constructor","Array","id","currentOutcome","filter","sort","cursor","Relations","currentRecord","e","_addWithData","manyOutcome","isMany","many","newObjectStore","put","_deleteWith","isDestroy","only","_setWithRelation","_sortAsNumbers","a","b","select","equal","where","setCaseInsensitive","lower","upper","incUpper","incLower","lowerOpen","upperBound","lowerBound","find","getId","get","add","createdAt","addMultiple","inserted","toAddData","between","whereIn","inValues","sortAsNumbers","gt","gte","lte","lt","getAll","whereNotIn","notInValues","deleteId","destroy","del","withRelations","withRelation","_getFieldConfig","config","hasOwnProperty","unique","multiEntry","_getIndexValue","keyPathValue","_createTables","objectStoreNames","contains","createObjectStore","keyPath","autoIncrement","other","indexValue","createIndex","models","_setFields","j","newFields","_setTables","i","timeStamps","indexOnTimeStamps","apply","then","type","res","rej","dbName","dbVersion","dbTables","setDbName","setDbTables","setDbVersion","$get","$inject","module","provider"],"mappings":"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","file":"angular-indexeddb.min.js","sourcesContent":["/*jslint browser: true*/\n/*global $q */\nfunction indexeddbProvider($windowProvider) {\n    'use strict';\n    var $window = $windowProvider.$get();\n\n    var dbName, dbVersion, dbTables;\n    dbName = 'test';\n    dbVersion = 1;\n    dbTables = [];\n\n\n    function initialize($q) {\n        /**\n         * Class : Function creates database and provides $q when database connection is resolved\n         * @param {string} name    [name of database]\n         * @param {integer} version [contains version number]\n         */\n        function CreateDB(name, version) {\n            var self = this;\n            self.name = name;\n            self.version = version;\n            self.indexdb = \"\";\n\n            /**\n             * Private : checks whether indexdb is supported by browser or not\n             */\n            function _check() {\n                self.indexdb = $window.indexedDB || $window.mozIndexedDB || $window.webkitIndexedDB || $window.msIndexedDB;\n                if (typeof self.indexdb !== \"object\") {\n                    throw \"IndexedDB not supported\";\n                }\n                self.keyRange = $window.IDBKeyRange || $window.mozIDBKeyRange || $window.webkitIDBKeyRange || $window.msIDBKeyRange;\n            }\n\n            _check();\n\n            self.open = new $window.Promise(function (resolve, reject) {\n\n                var connection = self.indexdb.open(self.name, self.version);\n                connection.onupgradeneeded = function (event) {\n                    resolve(event);\n                };\n                connection.onerror = function (event) {\n                    reject(event.srcElement.error);\n                };\n\n                connection.onsuccess = function (event) {\n                    resolve(event);\n                };\n            });\n\n        }\n\n        /**\n         * Class : class for maintaining and creating tables\n         * @param {string} name    [database name]\n         * @param {integer} version [version of database]\n         * @param {array} tables  [contains tables to be created]\n         */\n        function CreateTables(name, version, tables, qRes, qRej) {\n            CreateDB.apply(this, [name, version]);\n            var self = this;\n            self.tables = tables || [];\n            self.models = {};\n\n            function CreateModel(table) {\n                var model = this;\n                var connection;\n                var transaction;\n                var objectStore;\n\n                model.bound = null; //default bound value\n                model.index = null; //default index value\n                model.caseInsensitive = false; //default caseInsensitive value\n                model.hasFilter = false; //default if model has filter\n                model.filterFunction = null; //default filter function\n                model.whereInValues = null; //default whereInValues for whereIn\n                model.whereNotInValues = null; //default whereNotInValues for whereNotIn\n                model.withTables = {}; //with tables structure\n                model.hasWith = false; //default has with relation status\n\n                function _resetModel() {\n                    model.bound = null; //default bound value\n                    model.index = null; //default index value\n                    model.caseInsensitive = false; //default caseInsensitive value\n                    model.hasFilter = false; //default if model has filter\n                    model.filterFunction = null; //default filter function\n                    model.whereInValues = null; //default whereInValues for whereIn\n                    model.whereNotInValues = null; //default whereNotInValues for whereNotIn\n                    model.withTables = {}; //with tables structure\n                    model.hasWith = false; //default has with relation status\n                }\n\n                //private : function returns array of table names to perform transaction on\n                function _getTransactionTables() {\n                    var transactionTables = [];\n                    //default pushing main table name\n                    transactionTables.push(table.name);\n\n                    if (model.hasWith) {\n                        //pushing relation table names\n                        var withTables = Object.keys(model.withTables);\n                        withTables.forEach(function (withTable) {\n                            transactionTables.push(withTable);\n                        });\n\n                    }\n\n                    return transactionTables;\n                }\n\n                //private : wrapper for calling default getAll with callback for success\n                function _get(callback, readwrite) {\n\n                    //setting read write status flag of transaction\n                    var write = (readwrite === undefined || readwrite === false || readwrite === null) ? 'readonly' : 'readwrite';\n\n                    var transactionTables = [];\n                    var relations = {};\n\n                    return $q(function (resolve, reject) {\n                        connection = self.indexdb.open(self.name);\n                        connection.onsuccess = function (event) {\n\n                            var db = event.target.result;\n                            //opening transaction\n                            transactionTables = _getTransactionTables();\n                            transaction = db.transaction(transactionTables, write);\n\n                            //if model has with relation\n                            if (model.hasWith) {\n                                transactionTables.splice(0, 1);\n                                transactionTables.forEach(function (tableName) {\n                                    relations[tableName] = transaction.objectStore(tableName);\n                                });\n\n                            }\n\n                            objectStore = transaction.objectStore(table.name);\n\n                            //if index is defined then adding index to object store\n                            if (model.index !== null) {\n                                objectStore = objectStore.index(model.index);\n                            }\n\n                            objectStore = objectStore.openCursor(model.bound);\n\n                            //on success giving callback with promise and relation data\n                            objectStore.onsuccess = function (event) {\n                                callback(event, resolve, reject, relations);\n                            };\n\n                            objectStore.onerror = function (event) {\n                                _resetModel();\n                                reject(event.srcElement.error);\n                            };\n\n                            transaction.onerror = function (err) {\n                                _resetModel();\n                                reject(err.srcElement.error);\n                            };\n                        };\n\n                        connection.onerror = function (err) {\n                            _resetModel();\n                            reject(err.srcElement.error);\n                        };\n                    });\n                }\n\n                //private : function changes case of value if string type to lower or upper\n                function _changeCase(value, toUpper) {\n                    toUpper = (toUpper === undefined) ? false : toUpper;\n                    if (model.caseInsensitive) {\n                        if (typeof value === 'string') {\n                            value = (toUpper === true) ? value.toUpperCase() : value.toLowerCase();\n                        }\n                    }\n\n                    return value;\n                }\n\n                //private : function for where not in logic\n                function _whereNotIn(result, outcome, notInCaseInsensitiveArray) {\n                    //case sensitive\n                    if (model.caseInsensitive) {\n                        var resultKey = _changeCase(result.key);\n                        model.whereNotInValues.forEach(function (value) {\n                            var lowerValue = _changeCase(angular.copy(value));\n                            if (lowerValue === resultKey && notInCaseInsensitiveArray.indexOf(resultKey) === -1) {\n                                notInCaseInsensitiveArray.push(resultKey);\n                            }\n                        });\n\n                        if (notInCaseInsensitiveArray.indexOf(resultKey) === -1) {\n                            outcome.push(result.value);\n                        }\n\n                    } else {\n                        if (model.whereNotInValues.indexOf(result.key) === -1) {\n                            outcome.push(result.value);\n                        }\n                    }\n\n                    result.continue();\n                }\n\n                /**\n                 * The where in logic for the object store\n                 * @param  {IDBCursor} result             [contains current cursor value]\n                 * @param  {array} outcome            [contains final result where if condition passed data will be pushed]\n                 * @param  {integer} count              [current count of where in values iteration]\n                 * @param  {array} whereInValues      [whereIn values to search for]\n                 * @param  {boolean} useCaseInsensitive [override case sensitive search]\n                 * @return {integer}                    [returns new count value of next cursor]\n                 */\n                function _whereIn(result, outcome, count, whereInValues, useCaseInsensitive) {\n\n                    useCaseInsensitive = (useCaseInsensitive === undefined) ? true : useCaseInsensitive;\n\n                    //if case sensitive then checking throughout th database\n                    if (model.caseInsensitive && useCaseInsensitive) {\n                        var resultKey;\n                        resultKey = _changeCase(result.key);\n\n                        whereInValues.forEach(function (value) {\n                            var lowerValue = _changeCase(angular.copy(value));\n                            if (lowerValue === resultKey) {\n                                outcome.push(result.value);\n                            }\n                        });\n\n                        result.continue();\n                        return 0;\n                    }\n\n                    //case for case sensitive\n                    //if key greater than current value\n                    if (result.key > whereInValues[count]) {\n                        count = count + 1;\n                        result.continue();\n                        return count;\n                    }\n\n                    //if key not equal to current value then jumping to next\n                    if (result.key !== whereInValues[count]) {\n                        result.continue(whereInValues[count]);\n                        return count;\n                    }\n\n                    //pushing to outcome array\n                    outcome.push(result.value);\n                    count = count + 1;\n                    result.continue(whereInValues[count]);\n                    return count;\n                }\n\n                //private : function returns new object value to be updated with timestamps\n                function _updateValue(result, data, hasTimeStamp) {\n                    hasTimeStamp = (hasTimeStamp === undefined) ? false : hasTimeStamp;\n\n                    var newValue = angular.copy(result);\n\n                    var properties = Object.keys(data);\n                    properties.forEach(function (property) {\n                        newValue[property] = data[property];\n                    });\n\n                    if (table.hasTimeStamp && !hasTimeStamp) {\n                        newValue.updatedAt = Date.parse(Date());\n                    }\n\n                    if (hasTimeStamp) {\n                        newValue.updatedAt = Date.parse(Date());\n                    }\n\n                    return newValue;\n                }\n\n                //private : where in logic for update condition. When condition passes the system updates the object in current location\n                function _whereInUpdate(result, count, data) {\n                    var toUpdate = false;\n                    var newValue = _updateValue(result.value, data);\n\n                    //if case sensitive then checking throughout th database\n                    if (model.caseInsensitive) {\n                        var resultKey;\n                        resultKey = _changeCase(result.key);\n                        model.whereInValues.forEach(function (value) {\n                            var lowerValue = _changeCase(angular.copy(value));\n                            if (lowerValue === resultKey) {\n                                toUpdate = true;\n                            }\n                        });\n\n\n                        if (toUpdate) {\n                            result.update(newValue);\n                        }\n\n                        result.continue();\n                        return 0;\n                    }\n                    //case for case sensitive\n                    //if key greater than current value\n                    if (result.key > model.whereInValues[count]) {\n                        result.continue();\n                        count = count + 1;\n                        return count;\n                    }\n\n                    //if key not equal to current value then jumping to next\n                    if (result.key !== model.whereInValues[count]) {\n                        result.continue(model.whereInValues[count]);\n                        return count;\n\n                    }\n                    //pushing to outcome array\n                    result.update(newValue);\n                    count = count + 1;\n                    result.continue(model.whereInValues[count]);\n                    return count;\n                }\n\n                //private : function for where not in logic for update scenario\n                function _whereNotInUpdate(result, notInCaseInsensitiveArray, data) {\n\n                    var newValue = _updateValue(result.value, data); //data to be updated\n\n                    //case sensitive\n                    if (model.caseInsensitive) {\n                        var resultKey = _changeCase(result.key);\n                        model.whereNotInValues.forEach(function (value) {\n                            var lowerValue = _changeCase(angular.copy(value));\n                            if (lowerValue === resultKey && notInCaseInsensitiveArray.indexOf(resultKey) === -1) {\n                                notInCaseInsensitiveArray.push(resultKey);\n                            }\n                        });\n\n                        if (notInCaseInsensitiveArray.indexOf(resultKey) === -1) {\n                            result.update(newValue);\n                        }\n\n                    } else {\n                        if (model.whereNotInValues.indexOf(result.key) === -1) {\n                            result.update(newValue);\n                        }\n                    }\n\n                    result.continue();\n                }\n\n\n                //private : where in logic for deleting object\n                function _whereInDestroy(result, count, deletedIds) {\n                    var toDelete = false;\n\n                    //if case sensitive then checking throughout th database\n                    if (model.caseInsensitive) {\n                        var resultKey;\n                        resultKey = _changeCase(result.key);\n                        model.whereInValues.forEach(function (value) {\n                            var lowerValue = _changeCase(angular.copy(value));\n                            if (lowerValue === resultKey) {\n                                toDelete = true;\n                            }\n                        });\n\n                        //if to delete is set then deleting\n                        if (toDelete) {\n                            deletedIds.push(result.value[table.fields.keyPathField]);\n                            result.delete();\n                        }\n                        result.continue();\n                        return 0;\n                    }\n\n                    //case for case sensitive\n                    //if key greater than current value\n                    if (result.key > model.whereInValues[count]) {\n                        result.continue();\n                        count = count + 1;\n                        return count;\n                    }\n\n                    //if key not equal to current value then jumping to next\n                    if (result.key !== model.whereInValues[count]) {\n                        result.continue(model.whereInValues[count]);\n                        return count;\n                    }\n\n                    deletedIds.push(result.value[table.fields.keyPathField]);\n\n                    //pushing to outcome array\n                    result.delete();\n                    count = count + 1;\n                    result.continue(model.whereInValues[count]);\n                    return count;\n                }\n\n                //private : where not in logic for deleting\n                function _wherNotInDestroy(result, notInCaseInsensitiveArray, deletedIds) {\n                    //case sensitive\n                    if (model.caseInsensitive) {\n                        var resultKey = _changeCase(result.key);\n                        model.whereNotInValues.forEach(function (value) {\n                            var lowerValue = _changeCase(angular.copy(value));\n                            if (lowerValue === resultKey && notInCaseInsensitiveArray.indexOf(resultKey) === -1) {\n                                notInCaseInsensitiveArray.push(resultKey);\n                            }\n                        });\n\n                        if (notInCaseInsensitiveArray.indexOf(resultKey) === -1) {\n                            deletedIds.push(result.value[table.fields.keyPathField]);\n                            result.delete();\n                        }\n\n                    } else {\n                        if (model.whereNotInValues.indexOf(result.key) === -1) {\n                            deletedIds.push(result.value[table.fields.keyPathField]);\n                            result.delete();\n                        }\n                    }\n\n                    result.continue();\n                }\n\n\n                //private : function calls relation tables and fetches their data\n                /**\n                 * private : function calls relation tables and fetches their data\n                 * @param  {[type]}  resolve           [description]\n                 * @param  {[type]}  reject            [description]\n                 * @param  {array/object}  outcome           [contains main table record(s)]\n                 * @param  {object}  objectStoreTables [with tables in transaction mode]\n                 * @param  {Boolean} isFind            [true for find condition]\n                 */\n                function _getWithAllData(resolve, reject, outcome, objectStoreTables, isFind) {\n\n                    //setting default value for isFind\n                    isFind = (isFind === undefined) ? false : isFind;\n\n                    //checking if outcome is not empty\n                    if (isFind) {\n                        if (outcome === undefined) {\n\n                            _resetModel();\n                            resolve(outcome);\n                            return;\n                        }\n\n                    } else {\n                        if (outcome.length === 0) {\n                            _resetModel();\n                            resolve(outcome);\n                            return;\n                        }\n                    }\n                    var _id, withTablesCount, relationNames;\n\n                    relationNames = Object.keys(objectStoreTables); //getting relational table names\n                    withTablesCount = relationNames.length;\n\n                    var currentCount = 0;\n\n                    _id = [];\n\n                    //for each relational table\n                    relationNames.forEach(function (withTableName) {\n\n                        //retrieving main relationship join data\n                        if (isFind) {\n                            _id = angular.copy(outcome[model.originalWithRelation[withTableName].field]);\n\n                        } else {\n                            outcome.forEach(function (record) {\n                                var d = angular.copy(record[model.originalWithRelation[withTableName].field]);\n                                if (d !== undefined && d.constructor === Array) {\n                                    d.forEach(function (id) {\n                                        if (_id.indexOf(id) === -1) {\n                                            _id.push(id);\n                                        }\n                                    });\n                                }\n                            });\n                        }\n\n                        var count = 0;\n                        var currentOutcome = [];\n                        var hasFilter = false;\n\n                        //if filter was set in relation then setting hasFilter flag\n                        if (typeof model.originalWithRelation[withTableName].filter === 'function') {\n                            hasFilter = true;\n                        }\n\n                        _id = _id.sort();\n\n                        //opening relational table and fetching data\n                        objectStoreTables[withTableName].openCursor(self.keyRange.bound(_id[0], _id[(_id.length - 1)])).onsuccess = function (event) {\n                            var cursor = event.target.result;\n                            if (cursor) {\n\n                                //if relation has filter\n                                if (hasFilter) {\n\n                                    if (model.originalWithRelation[withTableName].filter(cursor.value) !== true) {\n                                        count = count + 1;\n                                        cursor.continue(_id[count]);\n                                        return;\n                                    }\n                                }\n\n                                count = _whereIn(cursor, currentOutcome, count, _id, false);\n\n                            } else {\n                                //when traversing is done\n\n                                if (isFind) {\n                                    //setting relation object to main outcome\n                                    outcome.Relations = outcome.Relations || {};\n                                    outcome.Relations[withTableName] = [];\n\n                                    //adding those with relation records which have relation with current record\n                                    currentOutcome.forEach(function (currentRecord) {\n                                        //adding the records to the main table\n                                        if (outcome[model.originalWithRelation[withTableName].field].indexOf(currentRecord._id) !== -1) {\n                                            outcome.Relations[withTableName].push(currentRecord);\n                                        }\n                                    });\n\n\n                                } else {\n                                    outcome.forEach(function (record) {\n                                        //setting relation object to main outcome\n                                        record.Relations = record.Relations || {};\n                                        record.Relations[withTableName] = [];\n\n                                        //adding those with relation records which have relation with current record\n                                        currentOutcome.forEach(function (currentRecord) {\n                                            //adding the records to the main table\n                                            if (record[model.originalWithRelation[withTableName].field].indexOf(currentRecord._id) !== -1) {\n                                                record.Relations[withTableName].push(currentRecord);\n                                            }\n                                        });\n                                    });\n                                }\n\n                                currentCount = currentCount + 1;\n\n                                //when all of the relation tables have completed traversing then resolving\n                                if (currentCount === withTablesCount) {\n                                    _resetModel();\n                                    resolve(outcome);\n                                }\n                            }\n                        };\n\n                        //case or error of in relation object store\n                        objectStoreTables[withTableName].openCursor(self.keyRange.bound(_id[0], _id[(_id.length - 1)])).onerror = function (e) {\n                            _resetModel();\n                            reject(e);\n                        };\n                    });\n\n                }\n\n                /**\n                 * private : function adds relation id to related tables. If many relation is set then also adds the relation tables record ids to the main table for creating many to many\n                 * @param {resolve} resolve           [resolves the promise]\n                 * @param {reject} reject            [rejects the promise]\n                 * @param {integer} outcome           [contains newly created records key path value]\n                 * @param {object} objectStoreTables [with tables in transaction mode]\n                 * @param {IDBTransaction} transaction       [transaction instance]\n                 */\n                function _addWithData(resolve, reject, outcome, objectStoreTables, transaction) {\n                    var withTablesCount, relationNames;\n\n                    relationNames = Object.keys(objectStoreTables); //getting relational table names\n                    withTablesCount = relationNames.length;\n\n                    var currentCount = 0;\n                    var manyOutcome = {};\n\n                    relationNames.forEach(function (withTableName) {\n                        var hasFilter = false; //setting if with table has filter\n                        var isMany = false; //if main table is in many to many relationship\n                        var many = [];\n\n                        //if filter was set in relation then setting hasFilter flag\n                        if (typeof model.originalWithRelation[withTableName].filter === 'function') {\n                            hasFilter = true;\n                        }\n\n                        //setting flag for many to many\n                        if (typeof model.originalWithRelation[withTableName].many === 'object') {\n                            if (model.originalWithRelation[withTableName].many.isMany === true) {\n                                isMany = true;\n                            }\n                        }\n\n                        //opening cursor on relation table\n                        objectStoreTables[withTableName].openCursor().onsuccess = function (event) {\n                            var cursor = event.target.result;\n\n                            if (cursor) {\n                                var newValue = _updateValue(cursor.value, {}, true);\n\n                                //if relation has filter\n                                if (hasFilter) {\n                                    if (model.originalWithRelation[withTableName].filter(angular.copy(cursor.value)) !== true) {\n                                        cursor.continue();\n                                        return;\n                                    }\n                                }\n\n                                //if property of relation is undefined then creating one as an array\n                                if (newValue[model.originalWithRelation[withTableName].field] === undefined) {\n                                    newValue[model.originalWithRelation[withTableName].field] = [];\n                                }\n\n                                //if relation does not have the index then adding it to list\n                                if (newValue[model.originalWithRelation[withTableName].field].indexOf(outcome._id) === -1) {\n                                    newValue[model.originalWithRelation[withTableName].field].push(outcome._id);\n\n                                    outcome.Relations = outcome.Relations || {};\n                                    outcome.Relations[withTableName] = outcome.Relations[withTableName] || [];\n\n                                    outcome.Relations[withTableName].push(cursor.value);\n\n                                    //case for many to many\n                                    if (isMany) {\n                                        many.push(cursor.value._id);\n                                    }\n                                }\n\n                                cursor.update(newValue);\n                                cursor.continue();\n\n                            } else {\n                                currentCount = currentCount + 1;\n\n                                //case for may then adding many relation to newly created object\n                                if (isMany) {\n                                    manyOutcome[model.originalWithRelation[withTableName].many.field] = many;\n                                }\n\n                                if (currentCount === withTablesCount) {\n\n                                    //if is many relationship then also updating current outcome value\n                                    if (isMany) {\n                                        outcome = _updateValue(outcome, manyOutcome);\n\n                                        var newObjectStore = transaction.objectStore(table.name);\n\n                                        newObjectStore.put(outcome).onsuccess = function () {\n                                            _resetModel();\n                                            resolve(outcome);\n                                        };\n\n                                        newObjectStore.onerror = function (error) {\n                                            _resetModel();\n                                            reject(error);\n                                        };\n\n                                    } else {\n                                        _resetModel();\n                                        resolve(outcome);\n                                    }\n                                }\n                            }\n                        };\n\n                        objectStoreTables[withTableName].openCursor().onerror = function (error) {\n                            _resetModel();\n                            reject(error);\n                        };\n                    });\n                }\n\n                /**\n                 * private : function delete the record relation to other tables\n                 * @param  {resolve}  resolve           [resolves the promise]\n                 * @param  {reject}  reject            [reject the promise]\n                 * @param  {array/integer}  value             [contains the id(s) of records delete]\n                 * @param  {object}  objectStoreTables [with tables in transaction mode]\n                 * @param  {Boolean} isDestroy         [for destroy mode]\n                 */\n                function _deleteWith(resolve, reject, value, objectStoreTables, isDestroy) {\n                    isDestroy = (isDestroy === undefined) ? false : isDestroy;\n                    var withTablesCount, relationNames;\n\n                    relationNames = Object.keys(objectStoreTables); //getting relational table names\n                    withTablesCount = relationNames.length;\n\n                    var currentCount = 0;\n                    var bound;\n\n                    //setting bound values for cursor location\n                    if (isDestroy) {\n                        value = value.sort();\n                        bound = self.keyRange.bound(value[0], value[(value.length - 1)]);\n                    } else {\n                        bound = self.keyRange.only(value);\n                    }\n\n                    relationNames.forEach(function (withTableName) {\n                        objectStoreTables[withTableName].index(model.originalWithRelation[withTableName].field).openCursor(bound).onsuccess = function (event) {\n                            var cursor = event.target.result;\n                            if (cursor) {\n                                var newValue = _updateValue(cursor.value, {}, true);\n                                if (newValue[model.originalWithRelation[withTableName].field] === undefined) {\n                                    cursor.continue();\n                                    return;\n                                }\n\n                                var index;\n                                if (isDestroy) {\n                                    value.forEach(function (_id) {\n                                        index = newValue[model.originalWithRelation[withTableName].field].indexOf(_id);\n\n                                        if (index !== -1) {\n                                            newValue[model.originalWithRelation[withTableName].field].splice(index, 1);\n                                        }\n                                    });\n                                } else {\n                                    index = newValue[model.originalWithRelation[withTableName].field].indexOf(value);\n\n                                    if (index === -1) {\n                                        cursor.continue();\n                                        return;\n                                    }\n\n                                    newValue[model.originalWithRelation[withTableName].field].splice(index, 1);\n                                }\n\n\n                                cursor.update(newValue);\n                                cursor.continue();\n\n                            } else {\n\n                                currentCount = currentCount + 1;\n\n                                if (currentCount === withTablesCount) {\n                                    _resetModel();\n                                    resolve();\n                                }\n                            }\n                        };\n\n                        objectStoreTables[withTableName].onerror = function (error) {\n                            _resetModel();\n                            reject(error);\n                        };\n                    });\n                }\n\n\n                /**\n                 * Function sets the with relations by creating new model instances\n                 * @param {object} relations [contains with relations data]\n                 */\n                function _setWithRelation(relations) {\n                    var withTables = Object.keys(relations);\n\n                    withTables.forEach(function (tableName) {\n                        //creating model for each instance\n                        model.withTables[tableName] = new CreateModel(tableName);\n                    });\n                }\n\n                //sorting where in/ where not in as number\n                function _sortAsNumbers(a, b) {\n                    return (a - b);\n                }\n\n                //selecting index to make searches upon\n                model.select = function (index) {\n                    if (index === table.fields.keyPathField) {\n                        return model;\n                    }\n                    model.index = index;\n                    return model;\n                };\n\n                //function sets equal value for index searching (not case sensitive)\n                model.equal = function (where) {\n                    model.bound = self.keyRange.only(where);\n                    return model;\n                };\n\n                //sets searches to case sensitive\n                model.setCaseInsensitive = function (value) {\n                    var lower, upper, incUpper, incLower;\n\n                    value = (value === undefined || value === true) ? true : false;\n                    model.caseInsensitive = value;\n\n                    //if model has been set to case insensitive and bound values are defined then\n                    if (model.caseInsensitive && model.bound !== null) {\n\n                        //case not of equal\n                        if (model.bound.lower !== model.bound.upper) {\n\n                            //setting bound values against case insensitive\n                            lower = _changeCase(angular.copy(model.bound.lower), true);\n                            incLower = (model.bound.lowerOpen === undefined) ? false : angular.copy(model.bound.lowerOpen);\n                            upper = _changeCase(angular.copy(model.bound.upper));\n                            incUpper = (model.bound.upper === undefined) ? false : angular.copy(model.bound.upper);\n\n                            //if lower bound is undefined then setting only upper bound\n                            if (model.bound.lower === undefined) {\n                                model.bound = self.keyRange.upperBound(upper, incUpper);\n\n                            } else if (model.bound.upper === undefined) {\n                                //if upper bound is undefined then setting only upper bound\n                                model.bound = self.keyRange.lowerBound(lower, incLower);\n\n                            } else {\n                                //else setting both bound values\n                                model.bound = self.keyRange.bound(lower, upper, incLower, incUpper);\n                            }\n\n                        }\n                    }\n\n                    return model;\n                };\n\n                //finds a single record according to value set (not case sensitive)\n                model.find = function () {\n\n                    var getId = $q(function (resolve, reject) {\n                        var transactionTables = [];\n                        var relations = {};\n\n                        connection = self.indexdb.open(self.name);\n                        connection.onsuccess = function (event) {\n                            var db = event.target.result;\n\n                            transactionTables = _getTransactionTables();\n                            transaction = db.transaction(transactionTables);\n\n                            if (model.hasWith) {\n                                transactionTables.splice(0, 1);\n                                transactionTables.forEach(function (withTableName) {\n                                    relations[withTableName] = transaction.objectStore(withTableName);\n                                });\n                            }\n\n                            objectStore = transaction.objectStore(table.name);\n\n                            //if index is set then searching on the index\n                            if (model.index !== null) {\n                                objectStore = objectStore.index(model.index);\n                            }\n                            objectStore.get(model.bound).onsuccess = function (record) {\n\n                                if (model.hasWith) {\n                                    _getWithAllData(resolve, reject, record.target.result, relations, true);\n\n                                } else {\n                                    _resetModel();\n                                    resolve(record.target.result);\n                                }\n                            };\n\n\n                            transaction.onerror = function (err) {\n                                _resetModel();\n                                reject(err.srcElement.error);\n                            };\n                        };\n\n                        connection.onerror = function (err) {\n                            _resetModel();\n                            reject(err.srcElement.error);\n                        };\n                    });\n\n                    return getId;\n                };\n\n                //function adds single record\n                model.add = function (data) {\n\n                    var add = $q(function (resolve, reject) {\n                        var transactionTables = [];\n                        var relations = {};\n\n                        connection = self.indexdb.open(self.name);\n                        connection.onsuccess = function (event) {\n\n                            var db = event.target.result;\n\n                            transactionTables = _getTransactionTables();\n                            transaction = db.transaction(transactionTables, \"readwrite\");\n\n                            if (model.hasWith) {\n                                transactionTables.splice(0, 1);\n                                transactionTables.forEach(function (withTableName) {\n                                    relations[withTableName] = transaction.objectStore(withTableName);\n                                });\n                            }\n\n                            objectStore = transaction.objectStore(table.name);\n                            if (table.hasTimeStamp) {\n                                data.updatedAt = Date.parse(Date());\n                                data.createdAt = Date.parse(Date());\n                            }\n                            objectStore = objectStore.add(data);\n\n                            objectStore.onsuccess = function (event) {\n                                var result;\n                                result = data;\n\n                                //adding key path value to the data object after adding\n                                result[table.fields.keyPathField] = event.target.result;\n\n                                if (model.hasWith) {\n                                    _addWithData(resolve, reject, result, relations, transaction);\n                                } else {\n                                    _resetModel();\n                                    resolve(result);\n\n                                }\n                            };\n\n                            transaction.onerror = function (event) {\n                                _resetModel();\n                                reject(event.srcElement.error);\n                            };\n\n                        };\n\n                        connection.onerror = function (event) {\n                            _resetModel();\n                            reject(event.srcElement.error);\n                        };\n                    });\n\n                    return add;\n                };\n\n                //add multiple data at once in single transaction\n                model.addMultiple = function (data) {\n                    var outcome = [];\n                    var count = data.length; //total no of records to be inserted\n                    var inserted = 0; //no of records inserted\n\n                    var add = $q(function (resolve, reject) {\n\n                        connection = self.indexdb.open(self.name);\n                        connection.onsuccess = function (event) {\n\n                            var db = event.target.result;\n                            transaction = db.transaction([table.name], \"readwrite\");\n                            objectStore = transaction.objectStore(table.name);\n\n                            //for each record\n                            data.forEach(function (toAddData) {\n\n                                //adding time stamps if allowed\n                                if (table.hasTimeStamp) {\n                                    toAddData.updatedAt = Date.parse(Date());\n                                    toAddData.createdAt = Date.parse(Date());\n                                }\n\n                                //single add instance\n                                objectStore.add(toAddData).onsuccess = function (event) {\n                                    var result;\n                                    result = data[inserted];\n\n                                    //adding newly inserted key path value to the object\n                                    result[table.fields.keyPathField] = event.target.result;\n\n                                    outcome.push(result);\n                                    inserted = inserted + 1;\n\n                                    //if inserted count is equal to total no of records then resolving\n                                    if (inserted === count) {\n                                        _resetModel();\n                                        resolve(outcome);\n                                    }\n                                };\n                            });\n\n                            transaction.onerror = function (event) {\n                                _resetModel();\n                                reject(event.srcElement.error);\n                            };\n\n                        };\n\n                        connection.onerror = function (event) {\n                            _resetModel();\n                            reject(event.srcElement.error);\n                        };\n                    });\n\n                    return add;\n                };\n\n                //between function(not case sensitive)\n                model.between = function (lower, upper, incLower, incUpper) {\n                    incLower = (incLower !== undefined) ? false : incLower;\n                    incUpper = (incUpper !== undefined) ? false : incUpper;\n                    model.bound = self.keyRange.bound(lower, upper, incLower, incUpper);\n                    return model;\n                };\n\n                //where in model function for setting whereInValues\n                model.whereIn = function (inValues, sortAsNumbers) {\n\n                    sortAsNumbers = (sortAsNumbers === undefined) ? false : sortAsNumbers;\n                    inValues = (sortAsNumbers === true) ? inValues.sort(_sortAsNumbers) : inValues.sort();\n                    model.whereInValues = inValues;\n\n                    return model;\n                };\n\n                //function sets greater than value for index\n                model.gt = function (lower) {\n                    lower = _changeCase(lower, true);\n                    model.bound = self.keyRange.lowerBound(lower, true);\n                    return model;\n                };\n\n                //function sets greater than value for index including the value\n                model.gte = function (lower) {\n                    lower = _changeCase(lower, true);\n                    model.bound = self.keyRange.lowerBound(lower);\n                    return model;\n                };\n\n                //function sets less than value for index including the value\n                model.lte = function (upper) {\n                    upper = _changeCase(upper);\n                    model.bound = self.keyRange.upperBound(upper);\n                    return model;\n                };\n\n                //function sets less than value for index\n                model.lt = function (upper) {\n                    upper = _changeCase(upper);\n                    model.bound = self.keyRange.upperBound(upper, true);\n                    return model;\n                };\n\n                //function is default getAll function retrieves all data\n                model.getAll = function () {\n                    var outcome = [];\n                    var count = 0;\n                    var notInCaseInsensitiveArray = [];\n\n                    var getId = _get(function (event, resolve, reject, withTables) {\n                        var result = event.target.result;\n\n                        if (result) {\n\n                            //if model has filter\n                            if (model.hasFilter) {\n                                if (model.filterFunction(result.value) !== true) {\n                                    result.continue();\n                                    return;\n                                }\n                            }\n\n                            //first checking if model has whereInvalues then where not else default getAll\n                            if (model.whereInValues !== null) {\n                                count = _whereIn(result, outcome, count, model.whereInValues);\n\n                            } else if (model.whereNotInValues !== null) {\n                                _whereNotIn(result, outcome, notInCaseInsensitiveArray);\n\n                            } else {\n                                outcome.push(result.value);\n                                result.continue();\n                            }\n\n                        } else {\n\n                            //if model has relations then resolving when relation transactions are complete else resolving\n                            if (model.hasWith) {\n                                _getWithAllData(resolve, reject, outcome, withTables);\n\n                            } else {\n                                _resetModel();\n                                resolve(outcome);\n                            }\n                        }\n                    });\n                    return getId;\n                };\n\n                //function sets where not in values for model\n                model.whereNotIn = function (notInValues, sortAsNumbers) {\n\n                    sortAsNumbers = (sortAsNumbers === undefined) ? false : sortAsNumbers;\n                    notInValues = (sortAsNumbers === true) ? notInValues.sort(_sortAsNumbers) : notInValues.sort();\n                    model.whereNotInValues = notInValues;\n\n                    return model;\n                };\n\n                //wrapper function firing default put on the indexed db\n                model.put = function (data) {\n                    var put = $q(function (resolve, reject) {\n\n                        connection = self.indexdb.open(self.name);\n                        connection.onsuccess = function (event) {\n\n                            var db = event.target.result;\n                            transaction = db.transaction([table.name], \"readwrite\");\n                            objectStore = transaction.objectStore(table.name);\n\n                            if (table.hasTimeStamp) {\n                                data.updatedAt = Date.parse(Date());\n\n                                if (data.createdAt === undefined) {\n                                    data.createdAt = Date.parse(Date());\n                                }\n                            }\n\n                            //firing put method\n                            objectStore = objectStore.put(data);\n\n                            objectStore.onsuccess = function (event) {\n                                //adding newly/existing key path value to the object\n                                data[table.keyPathField] = event.target.result;\n                                _resetModel();\n                                resolve(data);\n                            };\n\n                            transaction.onerror = function (event) {\n                                _resetModel();\n                                reject(event.srcElement.error);\n                            };\n\n                        };\n\n                        connection.onerror = function (event) {\n                            _resetModel();\n                            reject(event.srcElement.error);\n                        };\n                    });\n\n                    return put;\n                };\n\n                //function fires update method on the model\n                model.update = function (data) {\n                    if (typeof data !== 'object') {\n                        throw \"Data must be type of object\";\n                    }\n\n                    var count = 0;\n                    var notInCaseInsensitiveArray = [];\n\n                    var update = _get(function (event, resolve) {\n                        var result = event.target.result;\n                        var newValue;\n\n                        if (result) {\n\n                            //if model has filter\n                            if (model.hasFilter) {\n                                if (model.filterFunction(result.value) !== true) {\n                                    result.continue();\n                                    return;\n                                }\n                            }\n\n                            //first for whereIn model values then whereNotIn else default\n                            if (model.whereInValues !== null) {\n                                count = _whereInUpdate(result, count, data);\n\n                            } else if (model.whereNotInValues !== null) {\n                                _whereNotInUpdate(result, notInCaseInsensitiveArray, data);\n\n                            } else {\n                                newValue = _updateValue(result, data);\n                                result.update(newValue);\n                                result.continue();\n                            }\n\n                        } else {\n                            _resetModel();\n                            resolve();\n                        }\n                    }, true);\n\n                    return update;\n                };\n\n                //functions sets the filter for traversing\n                model.filter = function (filterFunction) {\n                    model.hasFilter = true;\n                    model.filterFunction = filterFunction;\n                    return model;\n                };\n\n                //wrapper for default delete in indexeddb\n                model.delete = function (value) {\n\n                    if (value === undefined) {\n                        throw \"Empty value provided for deleting\";\n                    }\n\n                    var deleteId = $q(function (resolve, reject) {\n                        connection = self.indexdb.open(self.name);\n                        connection.onsuccess = function (event) {\n\n                            var db = event.target.result;\n                            var relations = {};\n\n                            var transactionTables = _getTransactionTables();\n                            transaction = db.transaction(transactionTables, 'readwrite');\n\n                            if (model.hasWith) {\n                                transactionTables.splice(0, 1);\n                                transactionTables.forEach(function (withTableName) {\n                                    relations[withTableName] = transaction.objectStore(withTableName);\n                                });\n                            }\n\n                            objectStore = transaction.objectStore(table.name);\n\n                            objectStore = objectStore.delete(value); //firing default delete\n\n                            objectStore.onsuccess = function () {\n\n                                if (model.hasWith) {\n                                    _deleteWith(resolve, reject, value, relations);\n                                } else {\n                                    _resetModel();\n                                    resolve();\n                                }\n                            };\n\n                            transaction.onerror = function (err) {\n                                _resetModel();\n                                reject(err.srcElement.error);\n                            };\n                        };\n\n                        connection.onerror = function (err) {\n                            _resetModel();\n                            reject(err.srcElement.error);\n                        };\n                    });\n\n                    return deleteId;\n                };\n\n                //function to delete on cursor location\n                model.destroy = function () {\n                    var count = 0;\n                    var notInCaseInsensitiveArray = [];\n                    var deletedIds = [];\n\n                    var del = _get(function (event, resolve, reject, relations) {\n                        var result = event.target.result;\n\n                        if (result) {\n                            //if model has filter\n                            if (model.hasFilter) {\n                                if (model.filterFunction(result.value) !== true) {\n                                    result.continue();\n                                    return;\n                                }\n                            }\n\n                            //first whereIn then whereNotIn else default destroy\n                            if (model.whereInValues !== null) {\n                                count = _whereInDestroy(result, count, deletedIds);\n\n                            } else if (model.whereNotInValues !== null) {\n                                _wherNotInDestroy(result, notInCaseInsensitiveArray, deletedIds);\n\n                            } else {\n                                deletedIds.push(result.value[table.fields.keyPathField]);\n                                result.delete();\n                                result.continue();\n                            }\n                        } else {\n\n                            if (model.hasWith) {\n                                _deleteWith(resolve, reject, deletedIds, relations, true);\n                            } else {\n                                _resetModel();\n                                resolve();\n                            }\n                        }\n                    }, true);\n\n                    return del;\n                };\n\n                //query builder for with relations\n                model.withRelations = function (relations) {\n                    if (typeof relations !== 'object') {\n                        throw \"WithRelation must be at type of object\";\n                    }\n\n                    model.hasWith = true;\n                    model.originalWithRelation = relations; //keeping a record of original relation data\n                    model.withRelation = _setWithRelation(relations); //setting objects for using with relations\n\n                    return model;\n                };\n            }\n\n            //function sets the index configure values(unique/multientry)\n            function _getFieldConfig(field) {\n                var config = {};\n                if (field.hasOwnProperty('unique')) {\n                    if (field.unique) {\n                        config.unique = true;\n                    }\n                }\n\n                if (field.hasOwnProperty('multiEntry')) {\n                    if (field.multiEntry) {\n                        config.multiEntry = true;\n                    }\n                }\n                return config;\n            }\n\n            //function sets keyPathValue if not provided\n            function _getIndexValue(field) {\n                if (field.keyPathValue === undefined) {\n                    return field.name;\n                }\n\n                return field.keyPathValue;\n            }\n\n\n            /**\n             * Private : function creates tables when upgrade function is fired\n             * @param  {event.target.result} db [it of result of event of upgradedneeded]\n             */\n            function _createTables(db) {\n                var objectStore, config;\n                self.tables.forEach(function (table) {\n\n                    //if table does not exist then creating it\n                    if (!db.objectStoreNames.contains(table.name)) {\n\n                        //setting auto increment to keyPath\n                        objectStore = db.createObjectStore(table.name, {\n                            keyPath: table.fields.keyPathField,\n                            autoIncrement: true\n                        });\n\n                        //creating other fields/indexes\n                        table.fields.other.forEach(function (field) {\n                            var indexValue = _getIndexValue(field);\n                            config = _getFieldConfig(field); //fetching configuration against the index\n                            objectStore.createIndex(field.name, indexValue, config);\n                        });\n                    }\n\n                    self.models[table.name] = new CreateModel(table);\n                });\n            }\n\n            //private : function sets the fields(indexes) and keyPath field value of table\n            function _setFields(fields, tableName) {\n                var j, field, keyPath, newFields;\n                keyPath = false;\n                newFields = {};\n                newFields.other = [];\n\n                //setting other fields and keyPath Field\n                for (j = fields.length - 1; j >= 0; j--) {\n                    field = fields[j];\n\n                    if (field.hasOwnProperty('keyPath')) {\n                        if (field.keyPath === true) {\n                            if (keyPath === true) {\n                                throw \"Error multiple keyPath defined in table \" + tableName;\n                            }\n\n                            newFields.keyPathField = field.name;\n                            keyPath = true;\n                        } else {\n                            newFields.other.push(field);\n                        }\n                    } else {\n                        newFields.other.push(field);\n                    }\n                }\n\n                //if no keyPath field was set then setting default as 'id'\n                if (!keyPath) {\n                    newFields.keyPathField = 'id';\n                }\n\n                return newFields;\n            }\n\n            //private : function prepares tables for creating them db and to create models against them\n            function _setTables() {\n                var i, table, fields;\n\n                //for each table\n                for (i = self.tables.length - 1; i >= 0; i--) {\n\n                    table = self.tables[i];\n                    table.hasTimeStamp = false; //default timestamps value as false\n\n                    //fetching fields data\n                    fields = _setFields(table.fields, table.name);\n                    table.fields = fields;\n\n                    //checking if timestamps property is set\n                    if (table.timeStamps === true) {\n                        table.hasTimeStamp = true; //setting timestamps to be true\n\n                        //checking if indexing on timestamps needs to be done\n                        if (table.indexOnTimeStamps === true) {\n\n                            //creating indexing on timestamps with multientry as configuration\n                            table.fields.other.push({\n                                name: 'updatedAt',\n                                keyPathValue: 'updatedAt',\n                                multiEntry: true\n                            });\n                            table.fields.other.push({\n                                name: 'createdAt',\n                                keyPathValue: 'createdAt',\n                                multiEntry: true\n                            });\n                        }\n                    }\n                }\n            }\n\n            _setTables();\n\n            self.open.then(function (event) {\n                //when database is being upgraded\n                if (event.type === \"upgradeneeded\") {\n                    _createTables(event.target.result);\n\n                } else {\n                    self.tables.forEach(function (table) {\n                        self.models[table.name] = new CreateModel(table);\n                    });\n                }\n                qRes(self);\n\n            }).catch(function (event) {\n                qRej(event);\n            });\n\n        }\n\n        return $q(function (res, rej) {\n            var a = new CreateTables(dbName, dbVersion, dbTables, res, rej);\n            return a;\n        });\n    }\n\n    initialize.$inject = ['$q'];\n\n    function setDbName(name) {\n        dbName = name;\n    }\n\n    function setDbTables(tables) {\n        dbTables = tables;\n    }\n\n    function setDbVersion(version) {\n        dbVersion = version;\n    }\n\n\n    return {\n        setDbName: setDbName,\n        setDbVersion: setDbVersion,\n        setDbTables: setDbTables,\n        $get: initialize\n    };\n\n\n}\n\nindexeddbProvider.$inject = ['$windowProvider'];\nangular.module('indexed-db', []);\nangular.module('indexed-db').provider('indexeddb', indexeddbProvider);\n"],"sourceRoot":"/source/"}