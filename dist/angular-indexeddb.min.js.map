/**
 * gaurav-angular-indexeddb - IndexedDB wrapper for Angular JS
 * @version v0.1.0
 * @link https://github.com/gauravgango/gaurav-angular-indexeddb
 * @license MIT
 */
{"version":3,"sources":["angular-indexeddb.js"],"names":["indexeddbProvider","$windowProvider","initialize","$q","CreateDB","name","version","_check","self","indexdb","$window","indexedDB","mozIndexedDB","webkitIndexedDB","msIndexedDB","keyRange","IDBKeyRange","mozIDBKeyRange","webkitIDBKeyRange","msIDBKeyRange","this","open","Promise","resolve","reject","connection","onupgradeneeded","event","onerror","onsuccess","CreateTables","tables","qRes","qRej","CreateModel","table","_defaultModelSettings","model","bound","index","caseInsensitive","hasFilter","filterFunction","whereInValues","whereNotInValues","withTables","hasWith","isDesc","traverse","isWhereNumber","originalWithRelation","likeString","_getTransactionTables","transactionTables","push","Object","keys","forEach","withTable","_checkLikeString","recordKey","key","angular","copy","toString","toLowerCase","match","_get","callback","readwrite","write","undefined","relations","db","target","result","transaction","splice","tableName","objectStore","openCursor","exception","error","_changeCase","value","toUpper","toUpperCase","_whereNotIn","outcome","notInCaseInsensitiveArray","resultKey","lowerValue","indexOf","_whereIn","count","useCaseInsensitive","_updateValue","data","hasTimeStamp","newValue","properties","property","updatedAt","Date","parse","_updateWithRelation","record","relation","_whereInUpdate","toUpdate","update","_whereNotInUpdate","_whereInDestroy","deletedIds","toDelete","fields","keyPathField","_wherNotInDestroy","_getWithAllData","objectStoreTables","isFind","length","_id","withTablesCount","relationNames","Relations","currentCount","withTableName","field","d","constructor","Array","id","currentOutcome","filter","sort","cursor","currentRecord","e","_addWithData","manyOutcome","isMany","many","newObjectStore","put","_deleteWith","isDestroy","only","_setWithRelation","_sortAsNumbers","a","b","_setOrderSettings","reverse","orderDesc","select","equal","where","setCaseInsensitive","lower","upper","incUpper","incLower","lowerOpen","upperBound","lowerBound","find","getId","get","add","createdAt","srcElement","addMultiple","inserted","toAddData","between","whereIn","inValues","sortAsNumbers","gt","gte","lte","lt","getAll","whereNotIn","notInValues","deleteId","destroy","del","withRelations","withRelation","like","_getFieldConfig","config","hasOwnProperty","unique","multiEntry","_getIndexValue","keyPathValue","_createModelInstance","objectStoreNames","contains","keyPath","models","defineProperty","_createTables","createObjectStore","autoIncrement","other","indexValue","createIndex","_setFields","j","newFields","fieldNames","_setTables","i","tableNames","timeStamps","indexOnTimeStamps","apply","then","l","type","res","rej","dbName","dbVersion","dbTables","setDbName","setDbTables","setDbVersion","$get","$inject","module","provider"],"mappings":"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","file":"angular-indexeddb.min.js","sourcesContent":["/*jslint browser: true*/\n/*global $q */\nfunction indexeddbProvider($windowProvider) {\n    'use strict';\n    var $window = $windowProvider.$get();\n\n    var dbName, dbVersion, dbTables;\n    dbName = 'test';\n    dbVersion = 1;\n    dbTables = [];\n\n\n    function initialize($q) {\n        /**\n         * Class : Function creates database and provides $q when database connection is resolved\n         * @param {string} name    [name of database]\n         * @param {integer} version [contains version number]\n         */\n        function CreateDB(name, version) {\n            var self = this;\n            self.name = name;\n            self.version = version;\n            self.indexdb = \"\";\n\n            /**\n             * Private : checks whether indexdb is supported by browser or not\n             */\n            function _check() {\n                self.indexdb = $window.indexedDB || $window.mozIndexedDB || $window.webkitIndexedDB || $window.msIndexedDB;\n                if (typeof self.indexdb !== \"object\") {\n                    throw \"IndexedDB not supported\";\n                }\n                self.keyRange = $window.IDBKeyRange || $window.mozIDBKeyRange || $window.webkitIDBKeyRange || $window.msIDBKeyRange;\n            }\n\n            _check();\n\n            self.open = new $window.Promise(function (resolve, reject) {\n\n                var connection = self.indexdb.open(self.name, self.version);\n                connection.onupgradeneeded = function (event) {\n                    resolve(event);\n                };\n                connection.onerror = function (event) {\n                    reject(event);\n                };\n\n                connection.onsuccess = function (event) {\n                    resolve(event);\n                };\n            });\n\n        }\n\n        /**\n         * Class : class for maintaining and creating tables\n         * @param {string} name    [database name]\n         * @param {integer} version [version of database]\n         * @param {array} tables  [contains tables to be created]\n         */\n        function CreateTables(name, version, tables, qRes, qRej) {\n            CreateDB.apply(this, [name, version]);\n            var self = this;\n            self.tables = tables || [];\n            self.models = {};\n\n            function CreateModel(table) {\n                var model = this;\n                var connection;\n                var transaction;\n                var objectStore;\n\n                function _defaultModelSettings() {\n                    model.bound = null; //default bound value\n                    model.index = null; //default index value\n                    model.caseInsensitive = false; //default caseInsensitive value\n                    model.hasFilter = false; //default if model has filter\n                    model.filterFunction = null; //default filter function\n                    model.whereInValues = null; //default whereInValues for whereIn\n                    model.whereNotInValues = null; //default whereNotInValues for whereNotIn\n                    model.withTables = {}; //with tables structure\n                    model.hasWith = false; //default has with relation status\n                    model.isDesc = false; //default descending travers set to false\n                    model.traverse = 'next'; //default travering set to ascending\n                    model.isWhereNumber = false; //default where claues not containing number\n                    model.originalWithRelation = null; //default original with relation data\n                    model.likeString = null; //default likeString data\n                }\n\n                _defaultModelSettings();\n\n                //private : function returns array of table names to perform transaction on\n                function _getTransactionTables() {\n                    var transactionTables = [];\n                    //default pushing main table name\n                    transactionTables.push(table.name);\n\n                    if (model.hasWith) {\n                        //pushing relation table names\n                        var withTables = Object.keys(model.withTables);\n                        withTables.forEach(function (withTable) {\n                            transactionTables.push(withTable);\n                        });\n\n                    }\n\n                    return transactionTables;\n                }\n\n                //private function checks for like functionality in record key value\n                function _checkLikeString(recordKey) {\n                    var key = angular.copy(recordKey);\n                    key = key.toString();\n\n                    //if case insensitive\n                    if (model.caseInsensitive) {\n                        key = key.toLowerCase();\n                        return (key.match(model.likeString.toLowerCase()) !== null);\n                    }\n\n                    return (key.match(model.likeString) !== null);\n\n\n                }\n\n                //private : wrapper for calling default getAll with callback for success\n                function _get(callback, readwrite) {\n\n                    //setting read write status flag of transaction\n                    var write = (readwrite === undefined || readwrite === false || readwrite === null) ? 'readonly' : 'readwrite';\n\n                    var transactionTables = [];\n                    var relations = {};\n\n                    return $q(function (resolve, reject) {\n                        try {\n                            connection = self.indexdb.open(self.name);\n                            connection.onsuccess = function (event) {\n\n                                var db = event.target.result;\n                                //opening transaction\n                                transactionTables = _getTransactionTables();\n                                transaction = db.transaction(transactionTables, write);\n\n                                //if model has with relation\n                                if (model.hasWith) {\n                                    transactionTables.splice(0, 1);\n                                    transactionTables.forEach(function (tableName) {\n                                        relations[tableName] = transaction.objectStore(tableName);\n                                    });\n\n                                }\n\n                                objectStore = transaction.objectStore(table.name);\n\n                                //if index is defined then adding index to object store\n                                if (model.index !== null) {\n                                    objectStore = objectStore.index(model.index);\n                                }\n\n                                objectStore = objectStore.openCursor(model.bound, model.traverse);\n\n                                //on success giving callback with promise and relation data\n                                objectStore.onsuccess = function (event) {\n                                    try {\n                                        callback(event, resolve, reject, relations);\n\n                                    } catch (exception) {\n                                        reject(exception);\n                                    }\n                                };\n\n                                objectStore.onerror = function (error) {\n                                    reject(error);\n                                };\n\n                                transaction.onerror = function (error) {\n                                    reject(error);\n                                };\n                            };\n\n                            connection.onerror = function (error) {\n                                reject(error);\n                            };\n\n                        } catch (exception) {\n                            reject(exception);\n                        }\n                    });\n                }\n\n                //private : function changes case of value if string type to lower or upper\n                function _changeCase(value, toUpper) {\n                    toUpper = (toUpper === undefined) ? false : toUpper;\n                    if (model.caseInsensitive) {\n                        if (typeof value === 'string') {\n                            value = (toUpper === true) ? value.toUpperCase() : value.toLowerCase();\n                        }\n                    }\n\n                    return value;\n                }\n\n                //private : function for where not in logic\n                function _whereNotIn(result, outcome, notInCaseInsensitiveArray) {\n                    //case sensitive\n                    if (model.caseInsensitive) {\n                        var resultKey = _changeCase(result.key);\n                        model.whereNotInValues.forEach(function (value) {\n                            var lowerValue = _changeCase(angular.copy(value));\n                            if (lowerValue === resultKey && notInCaseInsensitiveArray.indexOf(resultKey) === -1) {\n                                notInCaseInsensitiveArray.push(resultKey);\n                            }\n                        });\n\n                        if (notInCaseInsensitiveArray.indexOf(resultKey) === -1) {\n                            outcome.push(result.value);\n                        }\n\n                    } else {\n                        if (model.whereNotInValues.indexOf(result.key) === -1) {\n                            outcome.push(result.value);\n                        }\n                    }\n\n                    result.continue(null, model.traverse);\n                }\n\n                /**\n                 * The where in logic for the object store\n                 * @param  {IDBCursor} result             [contains current cursor value]\n                 * @param  {array} outcome            [contains final result where if condition passed data will be pushed]\n                 * @param  {integer} count              [current count of where in values iteration]\n                 * @param  {array} whereInValues      [whereIn values to search for]\n                 * @param  {boolean} useCaseInsensitive [override case sensitive search]\n                 * @return {integer}                    [returns new count value of next cursor]\n                 */\n                function _whereIn(result, outcome, count, isDesc, traverse, whereInValues, useCaseInsensitive) {\n\n                    useCaseInsensitive = (useCaseInsensitive === undefined) ? true : useCaseInsensitive;\n\n                    //if case sensitive then checking throughout th database\n                    if (model.caseInsensitive && useCaseInsensitive) {\n                        var resultKey;\n                        resultKey = _changeCase(result.key);\n\n                        whereInValues.forEach(function (value) {\n                            var lowerValue = _changeCase(angular.copy(value));\n                            if (lowerValue === resultKey) {\n                                outcome.push(result.value);\n                            }\n                        });\n\n                        result.continue();\n                        return 0;\n                    }\n\n                    //case for case sensitive\n                    //case when where is is desc\n                    if (isDesc) {\n                        //if key less than current value\n                        if (result.key < whereInValues[count]) {\n                            count = count + 1;\n                            result.continue();\n                            return count;\n                        }\n                    } else {\n                        //case for ascending\n                        //if key greater than current value\n                        if (result.key > whereInValues[count]) {\n                            count = count + 1;\n                            result.continue();\n                            return count;\n                        }\n                    }\n\n                    //if key not equal to current value then jumping to next\n                    if (result.key !== whereInValues[count]) {\n                        result.continue(whereInValues[count], traverse);\n                        return count;\n                    }\n\n\n                    //pushing to outcome array\n                    outcome.push(result.value);\n                    count = count + 1;\n                    result.continue(whereInValues[count], traverse);\n                    return count;\n                }\n\n                //private : function returns new object value to be updated with timestamps\n                function _updateValue(result, data, hasTimeStamp) {\n                    hasTimeStamp = (hasTimeStamp === undefined) ? false : hasTimeStamp;\n\n                    var newValue = angular.copy(result);\n\n                    var properties = Object.keys(data);\n                    properties.forEach(function (property) {\n                        newValue[property] = data[property];\n                    });\n\n                    if (table.hasTimeStamp && !hasTimeStamp) {\n                        newValue.updatedAt = Date.parse(Date());\n                    }\n\n                    if (hasTimeStamp) {\n                        newValue.updatedAt = Date.parse(Date());\n                    }\n\n                    return newValue;\n                }\n\n                //private : function updates the relations indexes by adding new values\n                function _updateWithRelation(record, data) {\n                    //retrievinging properties to be updated\n                    var properties = Object.keys(data);\n\n                    properties.forEach(function (property) {\n                        //if property in main record is undefined\n                        if (record[property] === undefined) {\n                            record[property] = [];\n                        }\n                        data[property].forEach(function (relation) {\n                            //checking if relation already exists if not then adding\n\n                            //if relation is greter than or equla to zero then adding the relation\n                            if (relation >= 0) {\n                                if (record[property].indexOf(relation) === -1) {\n                                    record[property].push(relation);\n                                }\n                            } else {\n                                //else removing relation\n                                var index = record[property].indexOf(relation * (-1));\n                                if (index !== -1) {\n                                    record[property].splice(index, 1);\n                                }\n                            }\n                        });\n                    });\n\n                    return record;\n                }\n\n                //private : where in logic for update condition. When condition passes the system updates the object in current location\n                function _whereInUpdate(result, count, data) {\n                    var toUpdate = false;\n                    var newValue;\n\n                    //if case sensitive then checking throughout th database\n                    if (model.caseInsensitive) {\n                        var resultKey;\n                        resultKey = _changeCase(result.key);\n                        model.whereInValues.forEach(function (value) {\n                            var lowerValue = _changeCase(angular.copy(value));\n                            if (lowerValue === resultKey) {\n                                toUpdate = true;\n                            }\n                        });\n\n\n                        if (toUpdate) {\n                            newValue = _updateValue(result.value, data);\n\n                            //setting with relation data to the record as well\n                            if (model.hasWith) {\n                                newValue = _updateWithRelation(newValue, model.originalWithRelation);\n                            }\n                            result.update(newValue);\n                        }\n\n                        result.continue();\n                        return 0;\n                    }\n                    //case for case sensitive\n                    //case when where is is desc\n                    if (model.isDesc) {\n                        //if key less than current value\n                        if (result.key < model.whereInValues[count]) {\n                            count = count + 1;\n                            result.continue();\n                            return count;\n                        }\n                    } else {\n                        //case for ascending\n                        //if key greater than current value\n                        if (result.key > model.whereInValues[count]) {\n                            count = count + 1;\n                            result.continue();\n                            return count;\n                        }\n                    }\n\n                    //if key not equal to current value then jumping to next\n                    if (result.key !== model.whereInValues[count]) {\n                        result.continue(model.whereInValues[count]);\n                        return count;\n\n                    }\n\n                    newValue = _updateValue(result.value, data);\n\n                    //setting with relation data to the record as well\n                    if (model.hasWith) {\n                        newValue = _updateWithRelation(newValue, model.originalWithRelation);\n                    }\n                    //pushing to outcome array\n                    result.update(newValue);\n                    count = count + 1;\n                    result.continue(model.whereInValues[count]);\n                    return count;\n                }\n\n                //private : function for where not in logic for update scenario\n                function _whereNotInUpdate(result, notInCaseInsensitiveArray, data) {\n\n                    var newValue;\n\n                    //case sensitive\n                    if (model.caseInsensitive) {\n                        var resultKey = _changeCase(result.key);\n                        model.whereNotInValues.forEach(function (value) {\n                            var lowerValue = _changeCase(angular.copy(value));\n                            if (lowerValue === resultKey && notInCaseInsensitiveArray.indexOf(resultKey) === -1) {\n                                notInCaseInsensitiveArray.push(resultKey);\n                            }\n                        });\n\n                        if (notInCaseInsensitiveArray.indexOf(resultKey) === -1) {\n                            newValue = _updateValue(result.value, data); //data to be updated\n\n                            //setting with relation data to the record as well\n                            if (model.hasWith) {\n                                newValue = _updateWithRelation(newValue, model.originalWithRelation);\n                            }\n                            result.update(newValue);\n                        }\n\n                    } else {\n                        if (model.whereNotInValues.indexOf(result.key) === -1) {\n                            newValue = _updateValue(result.value, data); //data to be updated\n\n                            //setting with relation data to the record as well\n                            if (model.hasWith) {\n                                newValue = _updateWithRelation(newValue, model.originalWithRelation);\n                            }\n                            result.update(newValue);\n                        }\n                    }\n\n                    result.continue();\n                }\n\n\n                //private : where in logic for deleting object\n                function _whereInDestroy(result, count, deletedIds) {\n                    var toDelete = false;\n\n                    //if case sensitive then checking throughout th database\n                    if (model.caseInsensitive) {\n                        var resultKey;\n                        resultKey = _changeCase(result.key);\n                        model.whereInValues.forEach(function (value) {\n                            var lowerValue = _changeCase(angular.copy(value));\n                            if (lowerValue === resultKey) {\n                                toDelete = true;\n                            }\n                        });\n\n                        //if to delete is set then deleting\n                        if (toDelete) {\n                            deletedIds.push(result.value[table.fields.keyPathField]);\n                            result.delete();\n                        }\n                        result.continue();\n                        return 0;\n                    }\n\n                    //case for case sensitive\n                    //case when where is is desc\n                    if (model.isDesc) {\n                        //if key less than current value\n                        if (result.key < model.whereInValues[count]) {\n                            count = count + 1;\n                            result.continue();\n                            return count;\n                        }\n                    } else {\n                        //case for ascending\n                        //if key greater than current value\n                        if (result.key > model.whereInValues[count]) {\n                            count = count + 1;\n                            result.continue();\n                            return count;\n                        }\n                    }\n\n                    //if key not equal to current value then jumping to next\n                    if (result.key !== model.whereInValues[count]) {\n                        result.continue(model.whereInValues[count]);\n                        return count;\n                    }\n\n                    deletedIds.push(result.value[table.fields.keyPathField]);\n\n                    //pushing to outcome array\n                    result.delete();\n                    count = count + 1;\n                    result.continue(model.whereInValues[count]);\n                    return count;\n                }\n\n                //private : where not in logic for deleting\n                function _wherNotInDestroy(result, notInCaseInsensitiveArray, deletedIds) {\n                    //case sensitive\n                    if (model.caseInsensitive) {\n                        var resultKey = _changeCase(result.key);\n                        model.whereNotInValues.forEach(function (value) {\n                            var lowerValue = _changeCase(angular.copy(value));\n                            if (lowerValue === resultKey && notInCaseInsensitiveArray.indexOf(resultKey) === -1) {\n                                notInCaseInsensitiveArray.push(resultKey);\n                            }\n                        });\n\n                        if (notInCaseInsensitiveArray.indexOf(resultKey) === -1) {\n                            deletedIds.push(result.value[table.fields.keyPathField]);\n                            result.delete();\n                        }\n\n                    } else {\n                        if (model.whereNotInValues.indexOf(result.key) === -1) {\n                            deletedIds.push(result.value[table.fields.keyPathField]);\n                            result.delete();\n                        }\n                    }\n\n                    result.continue();\n                }\n\n\n                //private : function calls relation tables and fetches their data\n                /**\n                 * private : function calls relation tables and fetches their data\n                 * @param  {[type]}  resolve           [description]\n                 * @param  {[type]}  reject            [description]\n                 * @param  {array/object}  outcome           [contains main table record(s)]\n                 * @param  {object}  objectStoreTables [with tables in transaction mode]\n                 * @param  {Boolean} isFind            [true for find condition]\n                 */\n                function _getWithAllData(resolve, reject, outcome, objectStoreTables, isFind) {\n\n                    //setting default value for isFind\n                    isFind = (isFind === undefined) ? false : isFind;\n\n                    //checking if outcome is not empty\n                    if (isFind) {\n                        if (outcome === undefined) {\n                            resolve(outcome);\n                            return;\n                        }\n\n                    } else {\n                        if (outcome.length === 0) {\n                            resolve(outcome);\n                            return;\n                        }\n                    }\n                    var _id, withTablesCount, relationNames, Relations;\n\n                    Relations = {};\n\n                    relationNames = Object.keys(objectStoreTables); //getting relational table names\n                    withTablesCount = relationNames.length;\n\n                    var currentCount = 0;\n\n                    _id = [];\n\n                    //for each relational table\n                    relationNames.forEach(function (withTableName) {\n\n                        //retrieving main relationship join data\n                        if (isFind) {\n                            _id = angular.copy(outcome[model.originalWithRelation[withTableName].field]);\n\n                        } else {\n                            outcome.forEach(function (record) {\n                                var d = angular.copy(record[model.originalWithRelation[withTableName].field]);\n                                if (d !== undefined && d.constructor === Array) {\n                                    d.forEach(function (id) {\n                                        if (_id.indexOf(id) === -1) {\n                                            _id.push(id);\n                                        }\n                                    });\n                                }\n                            });\n                            Relations[withTableName] = [];\n                        }\n\n                        var count = 0;\n                        var currentOutcome = [];\n                        var hasFilter = false;\n\n                        //if filter was set in relation then setting hasFilter flag\n                        if (typeof model.originalWithRelation[withTableName].filter === 'function') {\n                            hasFilter = true;\n                        }\n                        if (_id === undefined || _id.constructor !== Array) {\n                            resolve(outcome);\n                        }\n\n                        _id = _id.sort();\n\n                        if (_id.length === 0) {\n\n                            if (isFind) {\n                                outcome.Relations = Relations;\n                            } else {\n                                outcome.forEach(function (record) {\n                                    record.Relations = Relations;\n                                });\n                            }\n                            resolve(outcome);\n                            return;\n                        }\n                        //opening relational table and fetching data\n                        objectStoreTables[withTableName].openCursor(self.keyRange.bound(_id[0], _id[(_id.length - 1)])).onsuccess = function (event) {\n                            try {\n\n                                var cursor = event.target.result;\n                                if (cursor) {\n\n                                    //if relation has filter\n                                    if (hasFilter) {\n\n                                        if (model.originalWithRelation[withTableName].filter(cursor.value) !== true) {\n                                            count = count + 1;\n                                            cursor.continue(_id[count]);\n                                            return;\n                                        }\n                                    }\n\n                                    count = _whereIn(cursor, currentOutcome, count, false, 'next', _id, false);\n\n                                } else {\n                                    //when traversing is done\n\n                                    if (isFind) {\n                                        //setting relation object to main outcome\n                                        outcome.Relations = outcome.Relations || {};\n                                        outcome.Relations[withTableName] = [];\n\n                                        //adding those with relation records which have relation with current record\n                                        currentOutcome.forEach(function (currentRecord) {\n                                            //adding the records to the main table\n                                            if (outcome[model.originalWithRelation[withTableName].field].indexOf(currentRecord._id) !== -1) {\n                                                outcome.Relations[withTableName].push(currentRecord);\n                                            }\n                                        });\n\n\n                                    } else {\n                                        outcome.forEach(function (record) {\n                                            //setting relation object to main outcome\n                                            record.Relations = record.Relations || {};\n                                            record.Relations[withTableName] = [];\n\n                                            //adding those with relation records which have relation with current record\n                                            currentOutcome.forEach(function (currentRecord) {\n                                                //adding the records to the main table\n                                                if (record[model.originalWithRelation[withTableName].field] !== undefined) {\n                                                    if (record[model.originalWithRelation[withTableName].field].indexOf(currentRecord._id) !== -1) {\n                                                        record.Relations[withTableName].push(currentRecord);\n                                                    }\n                                                }\n                                            });\n                                        });\n                                    }\n\n                                    currentCount = currentCount + 1;\n\n                                    //when all of the relation tables have completed traversing then resolving\n                                    if (currentCount === withTablesCount) {\n                                        resolve(outcome);\n                                    }\n                                }\n                            } catch (exception) {\n                                reject(exception);\n                            }\n                        };\n\n                        //case or error of in relation object store\n                        objectStoreTables[withTableName].openCursor(self.keyRange.bound(_id[0], _id[(_id.length - 1)])).onerror = function (e) {\n                            reject(e);\n                        };\n                    });\n\n                }\n\n                /**\n                 * private : function adds relation id to related tables. If many relation is set then also adds the relation tables record ids to the main table for creating many to many\n                 * @param {resolve} resolve           [resolves the promise]\n                 * @param {reject} reject            [rejects the promise]\n                 * @param {integer} outcome           [contains newly created records key path value]\n                 * @param {object} objectStoreTables [with tables in transaction mode]\n                 * @param {IDBTransaction} transaction       [transaction instance]\n                 */\n                function _addWithData(resolve, reject, outcome, objectStoreTables, transaction) {\n                    var withTablesCount, relationNames;\n\n                    relationNames = Object.keys(objectStoreTables); //getting relational table names\n                    withTablesCount = relationNames.length;\n\n                    var currentCount = 0;\n                    var manyOutcome = {};\n\n                    relationNames.forEach(function (withTableName) {\n                        var hasFilter = false; //setting if with table has filter\n                        var isMany = false; //if main table is in many to many relationship\n                        var many = [];\n\n                        //if filter was set in relation then setting hasFilter flag\n                        if (typeof model.originalWithRelation[withTableName].filter === 'function') {\n                            hasFilter = true;\n                        }\n\n                        //setting flag for many to many\n                        if (typeof model.originalWithRelation[withTableName].many === 'object') {\n                            if (model.originalWithRelation[withTableName].many.isMany === true) {\n                                isMany = true;\n                            }\n                        }\n\n                        //opening cursor on relation table\n                        objectStoreTables[withTableName].openCursor().onsuccess = function (event) {\n                            var cursor = event.target.result;\n\n                            if (cursor) {\n                                var newValue = _updateValue(cursor.value, {}, true);\n\n                                //if relation has filter\n                                if (hasFilter) {\n                                    if (model.originalWithRelation[withTableName].filter(angular.copy(cursor.value)) !== true) {\n                                        cursor.continue();\n                                        return;\n                                    }\n                                }\n\n                                //if property of relation is undefined then creating one as an array\n                                if (newValue[model.originalWithRelation[withTableName].field] === undefined) {\n                                    newValue[model.originalWithRelation[withTableName].field] = [];\n                                }\n\n                                //if relation does not have the index then adding it to list\n                                if (newValue[model.originalWithRelation[withTableName].field].indexOf(outcome._id) === -1) {\n                                    newValue[model.originalWithRelation[withTableName].field].push(outcome._id);\n\n                                    //case for many to many\n                                    if (isMany) {\n                                        many.push(cursor.value._id);\n                                    }\n                                }\n\n                                cursor.update(newValue);\n                                cursor.continue();\n\n                            } else {\n                                currentCount = currentCount + 1;\n\n                                //case for may then adding many relation to newly created object\n                                if (isMany === true) {\n                                    manyOutcome[model.originalWithRelation[withTableName].many.field] = many;\n                                }\n\n                                if (currentCount === withTablesCount) {\n\n                                    //if is many relationship then also updating current outcome value\n                                    if (isMany) {\n                                        outcome = _updateValue(outcome, manyOutcome);\n\n                                        var newObjectStore = transaction.objectStore(table.name);\n\n                                        newObjectStore.put(outcome).onsuccess = function () {\n                                            resolve(outcome);\n                                        };\n\n                                        newObjectStore.onerror = function (error) {\n                                            reject(error);\n                                        };\n\n                                    } else {\n                                        resolve(outcome);\n                                    }\n                                }\n                            }\n                        };\n\n                        objectStoreTables[withTableName].openCursor().onerror = function (error) {\n                            reject(error);\n                        };\n                    });\n                }\n\n                /**\n                 * private : function delete the record relation to other tables\n                 * @param  {resolve}  resolve           [resolves the promise]\n                 * @param  {reject}  reject            [reject the promise]\n                 * @param  {array/integer}  value             [contains the id(s) of records delete]\n                 * @param  {object}  objectStoreTables [with tables in transaction mode]\n                 * @param  {Boolean} isDestroy         [for destroy mode]\n                 */\n                function _deleteWith(resolve, reject, value, objectStoreTables, isDestroy) {\n                    isDestroy = (isDestroy === undefined) ? false : isDestroy;\n                    var withTablesCount, relationNames;\n\n                    relationNames = Object.keys(objectStoreTables); //getting relational table names\n                    withTablesCount = relationNames.length;\n\n                    var currentCount = 0;\n                    var bound;\n\n                    //setting bound values for cursor location\n                    if (isDestroy) {\n                        value = value.sort();\n                        bound = self.keyRange.bound(value[0], value[(value.length - 1)]);\n                    } else {\n                        bound = self.keyRange.only(value);\n                    }\n\n                    relationNames.forEach(function (withTableName) {\n                        objectStoreTables[withTableName].index(model.originalWithRelation[withTableName].field).openCursor(bound).onsuccess = function (event) {\n                            try {\n                                var cursor = event.target.result;\n                                if (cursor) {\n                                    var newValue = _updateValue(cursor.value, {}, true);\n                                    if (newValue[model.originalWithRelation[withTableName].field] === undefined) {\n                                        cursor.continue();\n                                        return;\n                                    }\n\n                                    var index;\n                                    if (isDestroy) {\n                                        value.forEach(function (_id) {\n                                            index = newValue[model.originalWithRelation[withTableName].field].indexOf(_id);\n\n                                            if (index !== -1) {\n                                                newValue[model.originalWithRelation[withTableName].field].splice(index, 1);\n                                            }\n                                        });\n                                    } else {\n                                        index = newValue[model.originalWithRelation[withTableName].field].indexOf(value);\n\n                                        if (index === -1) {\n                                            cursor.continue();\n                                            return;\n                                        }\n\n                                        newValue[model.originalWithRelation[withTableName].field].splice(index, 1);\n                                    }\n\n\n                                    cursor.update(newValue);\n                                    cursor.continue();\n\n                                } else {\n\n                                    currentCount = currentCount + 1;\n\n                                    if (currentCount === withTablesCount) {\n                                        resolve();\n                                    }\n                                }\n                            } catch (exception) {\n                                reject(exception);\n                            }\n\n                        };\n\n                        objectStoreTables[withTableName].onerror = function (error) {\n                            reject(error);\n                        };\n                    });\n                }\n\n\n                /**\n                 * Function sets the with relations by creating new model instances\n                 * @param {object} relations [contains with relations data]\n                 */\n                function _setWithRelation(relations) {\n                    var withTables = Object.keys(relations);\n\n                    withTables.forEach(function (tableName) {\n                        //creating model for each instance\n                        model.withTables[tableName] = new CreateModel(tableName);\n                    });\n                }\n\n                //sorting where in/ where not in as number\n                function _sortAsNumbers(a, b) {\n\n                    //if desc then returning b-a for descesding values\n                    if (model.isDesc) {\n                        return (b - a);\n                    }\n\n                    //returinng ascending values\n                    return (a - b);\n                }\n\n                function _setOrderSettings() {\n                    //setting wherein, wherenot in as values of is desc for sorting\n                    if (model.isDesc) {\n                        //case for descending order\n                        //if whereInValues are defined\n                        if (model.whereInValues !== null) {\n                            if (model.isWhereNumber) {\n                                model.whereInValues = model.whereInValues.sort(_sortAsNumbers);\n                                return;\n                            }\n\n                            model.whereInValues = model.whereInValues.reverse();\n                        }\n                        //if whereNotInValues are defined\n                        if (model.whereNotInValues !== null) {\n                            if (model.isWhereNumber) {\n                                model.whereNotInValues = model.whereNotInValues.sort(_sortAsNumbers);\n                                return;\n                            }\n\n                            model.whereNotInValues = model.whereNotInValues.reverse();\n                        }\n                    } else {\n                        //case for ascending order\n                        //if whereInValues are defined\n                        if (model.whereInValues !== null) {\n                            if (model.isWhereNumber) {\n                                model.whereInValues = model.whereInValues.sort(_sortAsNumbers);\n                                return;\n                            }\n\n                            model.whereInValues = model.whereInValues.sort();\n                        }\n                        //if whereNotInValues are defined\n                        if (model.whereNotInValues !== null) {\n                            if (model.isWhereNumber) {\n                                model.whereNotInValues = model.whereNotInValues.sort(_sortAsNumbers);\n                                return;\n                            }\n\n                            model.whereNotInValues = model.whereNotInValues.sort();\n\n                        }\n                    }\n                }\n\n                model.orderDesc = function (isDesc) {\n                    if (isDesc === true) {\n                        model.isDesc = true;\n                        model.traverse = 'prev';\n                        _setOrderSettings();\n\n                    } else {\n                        model.isDesc = false;\n                        model.traverse = 'next';\n                        _setOrderSettings();\n                    }\n\n                    return model;\n                };\n\n                //selecting index to make searches upon\n                model.select = function (index) {\n                    if (index === table.fields.keyPathField) {\n                        return model;\n                    }\n                    model.index = index;\n                    return model;\n                };\n\n                //function sets equal value for index searching (not case sensitive)\n                model.equal = function (where) {\n                    model.bound = self.keyRange.only(where);\n                    return model;\n                };\n\n                //sets searches to case sensitive\n                model.setCaseInsensitive = function (value) {\n                    var lower, upper, incUpper, incLower;\n\n                    value = (value === undefined || value === true) ? true : false;\n                    model.caseInsensitive = value;\n\n                    //if model has been set to case insensitive and bound values are defined then\n                    if (model.caseInsensitive && model.bound !== null) {\n\n                        //case not of equal\n                        if (model.bound.lower !== model.bound.upper) {\n\n                            //setting bound values against case insensitive\n                            lower = _changeCase(angular.copy(model.bound.lower), true);\n                            incLower = (model.bound.lowerOpen === undefined) ? false : angular.copy(model.bound.lowerOpen);\n                            upper = _changeCase(angular.copy(model.bound.upper));\n                            incUpper = (model.bound.upper === undefined) ? false : angular.copy(model.bound.upper);\n\n                            //if lower bound is undefined then setting only upper bound\n                            if (model.bound.lower === undefined) {\n                                model.bound = self.keyRange.upperBound(upper, incUpper);\n\n                            } else if (model.bound.upper === undefined) {\n                                //if upper bound is undefined then setting only upper bound\n                                model.bound = self.keyRange.lowerBound(lower, incLower);\n\n                            } else {\n                                //else setting both bound values\n                                model.bound = self.keyRange.bound(lower, upper, incLower, incUpper);\n                            }\n\n                        }\n                    }\n\n                    return model;\n                };\n\n                //finds a single record according to value set (not case sensitive)\n                model.find = function () {\n\n                    var getId = $q(function (resolve, reject) {\n                        var transactionTables = [];\n                        var relations = {};\n                        try {\n\n                            connection = self.indexdb.open(self.name);\n                            connection.onsuccess = function (event) {\n                                try {\n                                    var db = event.target.result;\n\n                                    transactionTables = _getTransactionTables();\n                                    transaction = db.transaction(transactionTables);\n\n                                    if (model.hasWith) {\n                                        transactionTables.splice(0, 1);\n                                        transactionTables.forEach(function (withTableName) {\n                                            relations[withTableName] = transaction.objectStore(withTableName);\n                                        });\n                                    }\n\n                                    objectStore = transaction.objectStore(table.name);\n\n                                    //if index is set then searching on the index\n                                    if (model.index !== null) {\n                                        objectStore = objectStore.index(model.index);\n                                    }\n\n                                    objectStore = objectStore.get(model.bound);\n                                    objectStore.onsuccess = function (record) {\n                                        try {\n\n                                            if (model.hasWith) {\n                                                _getWithAllData(resolve, reject, record.target.result, relations, true);\n\n                                            } else {\n                                                resolve(record.target.result);\n                                            }\n                                        } catch (exception) {\n                                            reject(exception);\n                                        }\n                                    };\n\n                                    objectStore.onerror = function (error) {\n                                        reject(error);\n                                    };\n\n                                    transaction.onerror = function (error) {\n                                        reject(error);\n                                    };\n\n                                } catch (exception) {\n                                    reject(exception);\n                                }\n                            };\n\n                            connection.onerror = function (error) {\n                                reject(error);\n                            };\n                        } catch (exception) {\n                            reject(exception);\n                        }\n\n                    });\n\n                    return getId;\n                };\n\n                //function adds single record\n                model.add = function (data) {\n\n                    var add = $q(function (resolve, reject) {\n                        try {\n\n                            var transactionTables = [];\n                            var relations = {};\n\n                            connection = self.indexdb.open(self.name);\n                            connection.onsuccess = function (event) {\n                                try {\n                                    var db = event.target.result;\n\n                                    transactionTables = _getTransactionTables();\n                                    transaction = db.transaction(transactionTables, \"readwrite\");\n\n                                    if (model.hasWith) {\n                                        transactionTables.splice(0, 1);\n                                        transactionTables.forEach(function (withTableName) {\n                                            relations[withTableName] = transaction.objectStore(withTableName);\n                                        });\n                                    }\n\n                                    objectStore = transaction.objectStore(table.name);\n                                    if (table.hasTimeStamp) {\n                                        data.updatedAt = Date.parse(Date());\n                                        data.createdAt = Date.parse(Date());\n                                    }\n                                    objectStore = objectStore.add(data);\n\n                                    objectStore.onsuccess = function (event) {\n                                        try {\n                                            var result;\n                                            result = data;\n\n                                            //adding key path value to the data object after adding\n                                            result[table.fields.keyPathField] = event.target.result;\n\n                                            if (model.hasWith) {\n                                                _addWithData(resolve, reject, result, relations, transaction);\n                                            } else {\n                                                resolve(result);\n\n                                            }\n\n                                        } catch (exception) {\n                                            reject(exception);\n                                        }\n\n                                    };\n\n                                    transaction.onerror = function (event) {\n                                        reject(event.srcElement.error);\n                                    };\n                                } catch (exception) {\n                                    reject(exception);\n                                }\n\n\n                            };\n\n                            connection.onerror = function (error) {\n                                reject(error);\n                            };\n                        } catch (exception) {\n                            reject(exception);\n                        }\n                    });\n\n                    return add;\n                };\n\n                //add multiple data at once in single transaction\n                model.addMultiple = function (data) {\n                    var outcome = [];\n                    var count = data.length; //total no of records to be inserted\n                    var inserted = 0; //no of records inserted\n\n                    var add = $q(function (resolve, reject) {\n                        try {\n                            connection = self.indexdb.open(self.name);\n                            connection.onsuccess = function (event) {\n                                try {\n\n                                    var db = event.target.result;\n                                    transaction = db.transaction([table.name], \"readwrite\");\n\n                                    try {\n\n                                        objectStore = transaction.objectStore(table.name);\n                                        //for each record\n                                        data.forEach(function (toAddData) {\n\n                                            //adding time stamps if allowed\n                                            if (table.hasTimeStamp) {\n                                                toAddData.updatedAt = Date.parse(Date());\n                                                toAddData.createdAt = Date.parse(Date());\n                                            }\n\n                                            //single add instance\n                                            objectStore.add(toAddData).onsuccess = function (event) {\n                                                try {\n                                                    var result;\n                                                    result = data[inserted];\n\n                                                    //adding newly inserted key path value to the object\n                                                    result[table.fields.keyPathField] = event.target.result;\n\n                                                    outcome.push(result);\n                                                    inserted = inserted + 1;\n\n                                                    //if inserted count is equal to total no of records then resolving\n                                                    if (inserted === count) {\n                                                        resolve(outcome);\n                                                    }\n                                                } catch (exception) {\n                                                    reject(exception);\n                                                }\n\n                                            };\n                                        });\n\n                                    } catch (exception) {\n                                        reject(exception);\n                                        return;\n                                    }\n\n\n                                    transaction.onerror = function (event) {\n                                        reject(event.srcElement.error);\n                                    };\n                                } catch (exception) {\n                                    reject(exception);\n                                }\n\n                            };\n\n                            connection.onerror = function (event) {\n\n                                reject(event.srcElement.error);\n                            };\n\n                        } catch (exception) {\n                            reject(exception);\n                        }\n\n                    });\n\n                    return add;\n                };\n\n                //between function(not case sensitive)\n                model.between = function (lower, upper, incLower, incUpper) {\n                    incLower = (incLower !== undefined) ? false : incLower;\n                    incUpper = (incUpper !== undefined) ? false : incUpper;\n                    model.bound = self.keyRange.bound(lower, upper, incLower, incUpper);\n                    return model;\n                };\n\n                //where in model function for setting whereInValues\n                model.whereIn = function (inValues, sortAsNumbers) {\n\n                    sortAsNumbers = (sortAsNumbers === true) ? true : false;\n                    model.whereInValues = inValues;\n\n                    model.isWhereNumber = sortAsNumbers; //setting whereIn as number type\n\n                    _setOrderSettings(); //sorting whereInValues as order type\n\n                    return model;\n                };\n\n                //function sets greater than value for index\n                model.gt = function (lower) {\n                    lower = _changeCase(lower, true);\n                    model.bound = self.keyRange.lowerBound(lower, true);\n                    return model;\n                };\n\n                //function sets greater than value for index including the value\n                model.gte = function (lower) {\n                    lower = _changeCase(lower, true);\n                    model.bound = self.keyRange.lowerBound(lower);\n                    return model;\n                };\n\n                //function sets less than value for index including the value\n                model.lte = function (upper) {\n                    upper = _changeCase(upper);\n                    model.bound = self.keyRange.upperBound(upper);\n                    return model;\n                };\n\n                //function sets less than value for index\n                model.lt = function (upper) {\n                    upper = _changeCase(upper);\n                    model.bound = self.keyRange.upperBound(upper, true);\n                    return model;\n                };\n\n                //function is default getAll function retrieves all data\n                model.getAll = function () {\n                    var outcome = [];\n                    var count = 0;\n                    var notInCaseInsensitiveArray = [];\n\n                    var getId = _get(function (event, resolve, reject, withTables) {\n                        var result = event.target.result;\n\n                        if (result) {\n\n                            //if model has filter\n                            if (model.hasFilter) {\n                                if (model.filterFunction(result.value) !== true) {\n                                    result.continue();\n                                    return;\n                                }\n                            }\n\n                            //checking for likeness in data\n                            if (model.likeString !== null) {\n                                if (_checkLikeString(result.key) === false) {\n                                    result.continue();\n                                    return;\n                                }\n                            }\n\n                            //first checking if model has whereInValues then where not else default getAll\n                            if (model.whereInValues !== null) {\n                                count = _whereIn(result, outcome, count, model.isDesc, model.traverse, model.whereInValues);\n\n                            } else if (model.whereNotInValues !== null) {\n                                _whereNotIn(result, outcome, notInCaseInsensitiveArray);\n\n                            } else {\n                                outcome.push(result.value);\n                                result.continue();\n                            }\n\n                        } else {\n\n                            //if model has relations then resolving when relation transactions are complete else resolving\n                            if (model.hasWith) {\n                                _getWithAllData(resolve, reject, outcome, withTables);\n\n                            } else {\n                                resolve(outcome);\n                            }\n                        }\n                    });\n                    return getId;\n                };\n\n                //function sets where not in values for model\n                model.whereNotIn = function (notInValues, sortAsNumbers) {\n\n                    sortAsNumbers = (sortAsNumbers === true) ? true : false;\n                    model.whereNotInValues = notInValues;\n\n                    model.isWhereNumber = sortAsNumbers; //setting whereNotInValues as number type\n\n                    _setOrderSettings(); //setting whereNotInValues as asc or desc type\n                    return model;\n                };\n\n                //wrapper function firing default put on the indexed db\n                model.put = function (data) {\n                    var put = $q(function (resolve, reject) {\n                        try {\n\n                            connection = self.indexdb.open(self.name);\n                            connection.onsuccess = function (event) {\n\n                                var db = event.target.result;\n                                transaction = db.transaction([table.name], \"readwrite\");\n                                objectStore = transaction.objectStore(table.name);\n\n                                if (table.hasTimeStamp) {\n                                    data.updatedAt = Date.parse(Date());\n\n                                    if (data.createdAt === undefined) {\n                                        data.createdAt = Date.parse(Date());\n                                    }\n                                }\n\n                                //firing put method\n                                objectStore = objectStore.put(data);\n\n                                objectStore.onsuccess = function (event) {\n                                    try {\n                                        //adding newly/existing key path value to the object\n                                        data[table.keyPathField] = event.target.result;\n                                        resolve(data);\n\n                                    } catch (exception) {\n                                        reject(exception);\n                                    }\n                                };\n\n                                objectStore.onerror = function (error) {\n                                    reject(error);\n                                };\n\n                                transaction.onerror = function (error) {\n                                    reject(error);\n                                };\n\n                            };\n\n                            connection.onerror = function (event) {\n                                reject(event.srcElement.error);\n                            };\n                        } catch (exception) {\n                            reject(exception);\n                        }\n\n                    });\n\n                    return put;\n                };\n\n                //function fires update method on the model\n                model.update = function (data) {\n                    if (typeof data !== 'object') {\n                        throw \"Data must be type of object\";\n                    }\n\n                    var count = 0;\n                    var notInCaseInsensitiveArray = [];\n\n                    var update = _get(function (event, resolve) {\n                        var result = event.target.result;\n                        var newValue;\n\n                        if (result) {\n\n                            //if model has filter\n                            if (model.hasFilter) {\n                                if (model.filterFunction(result.value) !== true) {\n                                    result.continue();\n                                    return;\n                                }\n                            }\n\n                            //checking for likeness in data\n                            if (model.likeString !== null) {\n                                if (_checkLikeString(result.key) === false) {\n                                    result.continue();\n                                    return;\n                                }\n                            }\n\n                            //first for whereIn model values then whereNotIn else default\n                            if (model.whereInValues !== null) {\n                                count = _whereInUpdate(result, count, data);\n\n                            } else if (model.whereNotInValues !== null) {\n                                _whereNotInUpdate(result, notInCaseInsensitiveArray, data);\n\n                            } else {\n                                newValue = _updateValue(result.value, data);\n\n                                //setting with relation data to the record as well\n                                if (model.hasWith) {\n                                    newValue = _updateWithRelation(newValue, model.originalWithRelation);\n                                }\n\n                                result.update(newValue);\n                                result.continue();\n                            }\n\n                        } else {\n                            resolve();\n                        }\n                    }, true);\n\n                    return update;\n                };\n\n                //functions sets the filter for traversing\n                model.filter = function (filterFunction) {\n                    model.hasFilter = true;\n                    model.filterFunction = filterFunction;\n                    return model;\n                };\n\n                //wrapper for default delete in indexeddb\n                model.delete = function (value) {\n\n                    if (value === undefined) {\n                        throw \"Empty value provided for deleting\";\n                    }\n\n                    var deleteId = $q(function (resolve, reject) {\n                        try {\n\n                            connection = self.indexdb.open(self.name);\n                            connection.onsuccess = function (event) {\n\n                                var db = event.target.result;\n                                var relations = {};\n\n                                var transactionTables = _getTransactionTables();\n                                transaction = db.transaction(transactionTables, 'readwrite');\n\n                                if (model.hasWith) {\n                                    transactionTables.splice(0, 1);\n                                    transactionTables.forEach(function (withTableName) {\n                                        relations[withTableName] = transaction.objectStore(withTableName);\n                                    });\n                                }\n\n                                objectStore = transaction.objectStore(table.name);\n\n                                objectStore = objectStore.delete(value); //firing default delete\n\n                                objectStore.onsuccess = function () {\n                                    try {\n                                        if (model.hasWith) {\n                                            _deleteWith(resolve, reject, value, relations);\n                                        } else {\n                                            resolve();\n                                        }\n                                    } catch (exception) {\n                                        reject(exception);\n                                    }\n\n                                };\n\n                                objectStore.onerror = function (error) {\n                                    reject(error);\n                                };\n\n                                transaction.onerror = function (error) {\n                                    reject(error);\n                                };\n                            };\n\n                            connection.onerror = function (error) {\n                                reject(error);\n                            };\n                        } catch (exception) {\n                            reject(exception);\n                        }\n                    });\n\n                    return deleteId;\n                };\n\n                //function to delete on cursor location\n                model.destroy = function () {\n                    var count = 0;\n                    var notInCaseInsensitiveArray = [];\n                    var deletedIds = [];\n\n                    var del = _get(function (event, resolve, reject, relations) {\n                        var result = event.target.result;\n\n                        if (result) {\n                            //if model has filter\n                            if (model.hasFilter) {\n                                if (model.filterFunction(result.value) !== true) {\n                                    result.continue();\n                                    return;\n                                }\n                            }\n\n                            //checking for likeness in data\n                            if (model.likeString !== null) {\n                                if (_checkLikeString(result.key) === false) {\n                                    result.continue();\n                                    return;\n                                }\n                            }\n\n                            //first whereIn then whereNotIn else default destroy\n                            if (model.whereInValues !== null) {\n                                count = _whereInDestroy(result, count, deletedIds);\n\n                            } else if (model.whereNotInValues !== null) {\n                                _wherNotInDestroy(result, notInCaseInsensitiveArray, deletedIds);\n\n                            } else {\n                                deletedIds.push(result.value[table.fields.keyPathField]);\n                                result.delete();\n                                result.continue();\n                            }\n                        } else {\n\n                            if (model.hasWith) {\n                                _deleteWith(resolve, reject, deletedIds, relations, true);\n                            } else {\n                                resolve();\n                            }\n                        }\n                    }, true);\n\n                    return del;\n                };\n\n                //query builder for with relations\n                model.withRelations = function (relations) {\n                    if (typeof relations !== 'object') {\n                        throw \"WithRelation must be at type of object\";\n                    }\n\n                    model.hasWith = true;\n                    model.originalWithRelation = relations; //keeping a record of original relation data\n                    model.withRelation = _setWithRelation(relations); //setting objects for using with relations\n\n                    return model;\n                };\n\n                model.like = function (likeString) {\n                    if (likeString === undefined) {\n                        throw \"Invalid input given to like\";\n                    }\n\n                    model.likeString = likeString.toString();\n                    return model;\n                };\n            }\n\n            //function sets the index configure values(unique/multientry)\n            function _getFieldConfig(field) {\n                var config = {};\n                if (field.hasOwnProperty('unique')) {\n                    if (field.unique) {\n                        config.unique = true;\n                    }\n                }\n\n                if (field.hasOwnProperty('multiEntry')) {\n                    if (field.multiEntry) {\n                        config.multiEntry = true;\n                    }\n                }\n                return config;\n            }\n\n            //function sets keyPathValue if not provided\n            function _getIndexValue(field) {\n                if (field.keyPathValue === undefined) {\n                    return field.name;\n                }\n\n                return field.keyPathValue;\n            }\n\n            function _createModelInstance(db, table) {\n                var objectStore;\n                if (db.objectStoreNames.contains(table.name)) {\n                    objectStore = db.transaction([table.name]).objectStore(table.name);\n\n                    //checking if table given exists in indexeddb\n                    if (objectStore.keyPath !== table.fields.keyPathField) {\n                        table.fields.keyPathField = objectStore.keyPath;\n                    }\n\n                    self.models[table.name] = {};\n                    //setting getter instance of object as new CreateModel instance\n                    Object.defineProperty(self.models, table.name, {\n                        get: function () {\n                            return new CreateModel(table);\n                        }\n                    });\n                }\n            }\n\n            /**\n             * Private : function creates tables when upgrade function is fired\n             * @param  {event.target.result} db [it of result of event of upgradedneeded]\n             */\n            function _createTables(db) {\n                var objectStore, config;\n                self.tables.forEach(function (table) {\n\n                    //if table does not exist then creating it\n                    if (!db.objectStoreNames.contains(table.name)) {\n\n                        //setting auto increment to keyPath\n                        objectStore = db.createObjectStore(table.name, {\n                            keyPath: table.fields.keyPathField,\n                            autoIncrement: true\n                        });\n\n                        //creating other fields/indexes\n                        table.fields.other.forEach(function (field) {\n                            var indexValue = _getIndexValue(field);\n                            config = _getFieldConfig(field); //fetching configuration against the index\n                            objectStore.createIndex(field.name, indexValue, config);\n                        });\n                    }\n\n                    self.models[table.name] = {};\n                    //setting getter instance of object as new CreateModel instance\n                    Object.defineProperty(self.models, table.name, {\n                        get: function () {\n                            return new CreateModel(table);\n                        }\n                    });\n                });\n            }\n\n            //private : function sets the fields(indexes) and keyPath field value of table\n            function _setFields(fields, tableName) {\n                var j, field, keyPath, newFields, fieldNames;\n                keyPath = false;\n                newFields = {};\n                newFields.other = [];\n                fieldNames = [];\n\n                //setting other fields and keyPath Field\n                for (j = fields.length - 1; j >= 0; j--) {\n                    field = fields[j];\n\n                    //validating field properties\n                    if (typeof field.name !== 'string') {\n                        throw \"Field/Index name must be of string type\";\n                    }\n\n                    if (fieldNames.indexOf(field.name) !== -1) {\n                        throw \"Field/Index name already exists\";\n                    }\n\n                    //pusghing to feildNames to check further fields of tables\n                    fieldNames.push(field.name);\n\n                    //checking field for keyPath property\n                    if (field.hasOwnProperty('keyPath')) {\n                        if (field.keyPath === true) {\n\n                            //checking if keyPath has already being set\n                            if (keyPath === true) {\n                                throw \"Error multiple keyPath defined in table \" + tableName;\n                            }\n                            //setting keyPath as this field \n                            newFields.keyPathField = field.name;\n                            keyPath = true; //setting keyPath flag as keyPath has been defined\n\n                        } else {\n                            //adding field to other array stating them as indexes\n                            newFields.other.push(field);\n                        }\n                    } else {\n                        //adding field to other array stating them as indexes\n                        newFields.other.push(field);\n                    }\n                }\n\n                //if no keyPath field was set then setting default as '_id'\n                if (!keyPath) {\n                    newFields.keyPathField = '_id';\n                }\n\n                return newFields;\n            }\n\n            //private : function prepares tables for creating them db and to create models against them\n            function _setTables() {\n                var i, table, fields, tableNames;\n                tableNames = [];\n                //for each table\n                for (i = self.tables.length - 1; i >= 0; i--) {\n\n                    table = self.tables[i];\n\n                    //validating table name type\n                    if (typeof table.name !== 'string') {\n                        throw \"Table/ObjectStore name must be of string type\";\n                    }\n\n                    if (tableNames.indexOf(table.name) !== -1) {\n                        throw \"Repeated Table/ObjectStore name \" + table.name;\n                    }\n\n                    //pusing to array to check further table names\n                    tableNames.push(table.name);\n\n                    table.hasTimeStamp = false; //default timestamps value as false\n\n                    //fetching fields data\n                    fields = _setFields(table.fields, table.name);\n                    table.fields = fields;\n\n                    //checking if timestamps property is set\n                    if (table.timeStamps === true) {\n                        table.hasTimeStamp = true; //setting timestamps to be true\n\n                        //checking if indexing on timestamps needs to be done\n                        if (table.indexOnTimeStamps === true) {\n\n                            //creating indexing on timestamps with multientry as configuration\n                            table.fields.other.push({\n                                name: 'updatedAt',\n                                keyPathValue: 'updatedAt',\n                                multiEntry: true\n                            });\n                            table.fields.other.push({\n                                name: 'createdAt',\n                                keyPathValue: 'createdAt',\n                                multiEntry: true\n                            });\n                        }\n                    }\n                }\n            }\n\n            _setTables();\n\n            self.open.then(function (event) {\n                var l, table;\n                //when database is being upgraded\n                if (event.type === \"upgradeneeded\") {\n                    _createTables(event.target.result);\n\n                } else {\n                    for (l = self.tables.length - 1; l >= 0; l--) {\n                        table = self.tables[l];\n                        _createModelInstance(event.target.result, table);\n\n                    }\n                }\n                qRes(self);\n\n            }).catch(function (event) {\n                qRej(event);\n            });\n\n        }\n\n        return $q(function (res, rej) {\n            var a = new CreateTables(dbName, dbVersion, dbTables, res, rej);\n            return a;\n        });\n    }\n\n    initialize.$inject = ['$q'];\n\n    function setDbName(name) {\n        dbName = name;\n    }\n\n    function setDbTables(tables) {\n        dbTables = tables;\n    }\n\n    function setDbVersion(version) {\n        dbVersion = version;\n    }\n\n\n    return {\n        setDbName: setDbName,\n        setDbVersion: setDbVersion,\n        setDbTables: setDbTables,\n        $get: initialize\n    };\n\n\n}\n\nindexeddbProvider.$inject = ['$windowProvider'];\nangular.module('indexed-db', []);\nangular.module('indexed-db').provider('indexeddb', indexeddbProvider);\n"],"sourceRoot":"/source/"}